<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>k8s基础概念</title>
    <url>/2020/08/19/k8s%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="k8s架构图"><a href="#k8s架构图" class="headerlink" title="k8s架构图"></a>k8s架构图</h2><p>Kubernetes的原型是Google公司在其10年容器化经验积累中打造的 “秘密武器”——Borg系统，得益于Google的大规模容器编排经验，k8s相比于其他容器解决方案思想更超前，更重要的是，k8s在开源社区落地后，又在整个社区的合力之下得到了极大的改进，修复了很多当年遗留在 Borg 体系中的缺陷和问题。</p>
<p>k8s集群的架构图如下：</p>
<a id="more"></a>

<img data-src="/2020/08/19/k8s%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image-20200819141844974.png" class="" title="image-20200819141844974">

<p>一个 Kubernetes 集群由一组节点（node, 可以是一台物理或虚拟的机器）组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点和至少一个主节点。工作节点托管作为应用程序组件的 Pod 。主节点管理集群中的工作节点和 Pod 。可以部署多个主节点用于为集群提供故障转移和高可用性。</p>
<h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）</h3><p>控制平面的组件对集群做出全局决策以及检测和响应集群事件，如负责Pod的调度，及Deployment副本数的维护等。</p>
<p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，通常会在主节点上部署所有的控制平面组件，且不会在部署了控制平面组件的节点上运行用户Pod。</p>
<h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>主节点上负责提供 Kubernetes API 服务的组件；它是 Kubernetes 控制面的前端。kube-apiserver 在设计上考虑了水平扩缩的需要。 换言之，通过部署多个实例可以实现扩缩。</p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>kube-scheduler监视那些新创建的未指定运行节点的 Pod，负责依据资源需求、亲和性等因素调度这些Pod到合适的节点上运行。</p>
<h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>kube-controller-manager为在主节点上运行的控制器的组件。</p>
<p>从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p>
<p>这些控制器包括:</p>
<ul>
<li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li>
<li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li>
<li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li>
<li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li>
</ul>
<h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>Kubernetes上可以运行各种容器环境，如<a href="http://www.docker.com/">Docker</a>、 <a href="https://containerd.io/">containerd</a>、<a href="https://cri-o.io/">cri-o</a>、 <a href="https://github.com/kubernetes-incubator/rktlet">rktlet</a> 等。</p>
<p>一个在集群中每个节点上都运行着一个kubelet，它通过直接跟容器引擎层交互，实现容器的生命周期管理。</p>
<h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>kube-proxy 是集群中每个节点上运行的网络代理,实现 Kubernetes Service 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络与 Pod 进行网络通信。</p>
<p>简言之，kube-proxy是负责写入规则至 IPTABLES、IPVS以 实现服务映射访问的。</p>
<h2 id="k8s-基础资源类型"><a href="#k8s-基础资源类型" class="headerlink" title="k8s 基础资源类型"></a>k8s 基础资源类型</h2><img data-src="/2020/08/19/k8s%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image-20200819114158487.png" class="" title="image-20200819114158487">

<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是 Kubernetes 项目中的最小编排单位，一个Pod内可以运行一个或多个容器，各容器共享一个网络栈。按照可自愈性，Pod又可分为自助式Pod和被控制器管理的Pod。其中自己单独创建的Pod未被任何控制器管理，当Pod异常退出时不会重启恢复。</p>
<img data-src="/2020/08/19/k8s%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image-20200819145759920.png" class="" title="image-20200819145759920">

<p>上图中，Pod中的容器A和容器B共享一套由Pod的基础容器Infra创建的网络栈。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器管理特定的Pod，Kubernetes推崇声明式API，我们只需告诉Kubernetes需要什么样的Pod，需要多少个副本，Kubernetes就在其控制循环里不断查询Pod的当前状态对比期望状态，使得Pod的状态向期望状态收敛。而背后真正控制Pod的创建与删除的，正是控制器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  实际状态 := 获取集群中对象X的实际状态（Actual State）</span><br><span class="line">  期望状态 := 获取集群中对象X的期望状态（Desired State）</span><br><span class="line">  <span class="keyword">if</span> 实际状态 == 期望状态&#123;</span><br><span class="line">    什么都不做</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行编排动作，将实际状态调整为期望状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ReplicaSet-ReplicationController"><a href="#ReplicaSet-ReplicationController" class="headerlink" title="ReplicaSet/ReplicationController"></a>ReplicaSet/ReplicationController</h4><p>ReplicationController和ReplicaSet用来确保容器应用的副本数始终和用户声明的副本数相等，即如果当前容器副本数大于声明数，会删除多余的Pod，如果Pod因异常退出等原因导致当前Pod数目小于声明数，控制器会创建新的Pod以满足副本数的要求。ReplicaSet与ReplicationController的唯一区别在于，ReplicaSet支持集合式的选择器，建议使用ReplicaSet。</p>
<h4 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h4><p>虽然可以直接声明ReplicaSet来管理Pod，但应用的部署还是推荐使用Deployment来自动管理ReplicaSet，且Deployment支持滚动更新和回滚。</p>
<img data-src="/2020/08/19/k8s%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image-20200819152959339.png" class="" title="image-20200819152959339">

<p>Deployment 控制器实际操纵的是 ReplicaSet 对象，而不是直接管理 Pod 对象；在更新时，Deployment会新建一个ReplicaSet并保留原ReplicaSet（用来回退），而ReplicaSet负责底层Pod的更新和回退。</p>
<h4 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a>StatefulSets</h4><p>相对于Deployment和ReplicaSets，StatefulSets的不同之处在于它是用来管理有状态的Pod的，其特点为：</p>
<ul>
<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据（基于PVC实现）</li>
<li>稳定的网络标识，即Pod被重新调度后其PodName和HostName保持不变（基于Headless Service实现）</li>
<li>有序部署，有序扩缩容，即Pod是有顺序的，在部署或扩展的时候要严格按照顺序依次执行（基于init conteiners实现）</li>
</ul>
<h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet保证在每个节点上都运行且只运行一个Pod实例，当有新的Node加入集群时，也会为该Node新增一个Pod，当有Node从集群移除时，该Pod被回收。删除DaemonSet会删除它所管理的所有Pod。</p>
<h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Jobs负责批处理任务，它保证任务Pod的成功结束。</p>
<h4 id="CronJobs"><a href="#CronJobs" class="headerlink" title="CronJobs"></a>CronJobs</h4><p>定时任务控制器，CronJob 与 Job 的关系，正如同 Deployment 与 ReplicaSet 的关系一样。CronJob 是一个专门用来管理 Job 对象的控制器。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s的网络通讯方式</title>
    <url>/2020/08/19/k8s%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Kubernetes网络模型"><a href="#Kubernetes网络模型" class="headerlink" title="Kubernetes网络模型"></a>Kubernetes网络模型</h2><p>Kubernetes对其网络模型做了如下假设：</p>
<ol>
<li>每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。</li>
<li>k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。</li>
<li>Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。</li>
<li>IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。</li>
</ol>
<a id="more"></a>

<h2 id="相同Pod内的容器通讯"><a href="#相同Pod内的容器通讯" class="headerlink" title="相同Pod内的容器通讯"></a>相同Pod内的容器通讯</h2><img data-src="/2020/08/19/k8s%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/image-20200819161114059.png" class="" title="image-20200819161114059">

<p>同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。</p>
<h2 id="相同Node不同Pod之间的容器通讯"><a href="#相同Node不同Pod之间的容器通讯" class="headerlink" title="相同Node不同Pod之间的容器通讯"></a>相同Node不同Pod之间的容器通讯</h2><img data-src="/2020/08/19/k8s%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/image-20200819162952537.png" class="" title="image-20200819162952537">

<p>同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。</p>
<p>在pause容器启动之前，会创建一个虚拟以太网接口对（veth pair），该接口对一端连着容器内部的eth0 ，一端连着容器外部的vethxxx，vethxxx会绑定到容器运行时配置使用的网桥bridge0上，从该网络的IP段中分配IP给容器的eth0。</p>
<p>当同节点上的Pod-1发包给Pod-2时，包传送路线如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pod-1的eth0—&gt;pod-1的vethxxx—&gt;bridge0—&gt;pod-2的vethxxx—&gt;pod-2的eth0</span><br></pre></td></tr></table></figure>

<p>因为相同节点的bridge0是相通的，因此可以通过bridge0来完成不同pod直接的通信，但是不同节点的bridge0是不通的，因此不同节点的pod之间的通信需要将不同节点的bridge0给连接起来。</p>
<h2 id="不同Node之间的容器通讯"><a href="#不同Node之间的容器通讯" class="headerlink" title="不同Node之间的容器通讯"></a>不同Node之间的容器通讯</h2><p>不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。</p>
<p>所以不同Node之间的通信需要达到两个条件：</p>
<ol>
<li>对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。</li>
<li>将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。</li>
</ol>
<p>不同节点的Pod之间的通信需要将不同节点的bridge0给连接起来。连接不同节点的bridge0的方式有好几种，主要有overlay和underlay，或常规的三层路由。</p>
<img data-src="/2020/08/19/k8s%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/image-20200819163845347.png" class="" title="image-20200819163845347">

<p>上图为Flannel UDP 模式提供的一个三层的 Overlay 网络，flannel0是一个 TUN 设备（Tunnel 设备），TUN 设备的功能非常简单，即：在操作系统内核和用户应用程序之间传递 IP 包。</p>
<p>当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包，交给创建这个设备的应用程序，也就是 Flannel 进程。这是一个从内核态（Linux 操作系统）向用户态（Flannel 进程）的流动方向。然后 Flannel 进程负责找到目标Node的IP封装UDP包并发给目标Node。Node 2 上监听 8285 端口的进程也是 flanneld，所以这时候，flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包，接下来Node2上的 flannel0 设备将数据包从用户态发送到内核态， Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向（发送给Docker0网桥，然后发给目标容器）。</p>
<p>总之：它首先对发出端的 IP 包进行 UDP 封装（根据目的 IP 的地址，匹配到对应的子网，从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3），然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p>
<h2 id="通过Service访问Pod"><a href="#通过Service访问Pod" class="headerlink" title="通过Service访问Pod"></a>通过Service访问Pod</h2><p>Service的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。</p>
<p>Kubernetes Porxy实现了以下功能：</p>
<ul>
<li>转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。</li>
<li>监控Service和Endpoints的变化，实时刷新转发规则。</li>
<li>负载均衡能力。</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s调度单元Pod</title>
    <url>/2020/08/20/k8s%E8%B0%83%E5%BA%A6%E5%8D%95%E5%85%83Pod/</url>
    <content><![CDATA[<h2 id="Pod概念"><a href="#Pod概念" class="headerlink" title="Pod概念"></a>Pod概念</h2><p>“Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统”，此为容器世界的三句箴言，而Kubernetes正是容器云世界里“操作系统”，从这个角度出发，我们可以把Pod类比为运行在操作系统里的“进程”，彼此间有着隔离；同时，一个Pod内部可以运行一个或多个容器，我们可以将这些容器类比成进程内的线程，它们可以共享一些资源，具备“超亲密”的关系。</p>
<a id="more"></a>

<ul>
<li>Pod是kubernetes集群中最小的部署和管理的基本单元。</li>
<li>Pod是一个或多个容器的集合，是一个或一组服务（进程）的抽象集合。</li>
<li>Pod中的容器之间可以共享网络和存储，而Pod之间却彼此隔离（可以简单理解为一个逻辑上的虚拟机，但并不是虚拟机）。</li>
</ul>
<h2 id="Pod资源定义文件"><a href="#Pod资源定义文件" class="headerlink" title="Pod资源定义文件"></a>Pod资源定义文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>        　　          <span class="comment">#必选，版本号，例如v1,版本号必须可以用 kubectl api-versions 查询到 .</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　　　　　　         <span class="comment">#必选，Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　　　　　　         <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>        　　          <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>     　　        <span class="comment">#必选，Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　　　　　          <span class="comment">#自定义标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          <span class="comment">#自定义标签名字</span></span><br><span class="line">  <span class="attr">annotations:</span>        　　                 <span class="comment">#自定义注释列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>         　　　　　　　            <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>       　　　　            <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　                <span class="comment">#必选，容器名称,需符合RFC 1035规范</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>     　　                <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像,否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]     　　        <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      　　             <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>                     <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>     　　　　        <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　　        <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span>                 <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span>                 <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span>        　　　　　　        <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　　        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>                <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>     　　             <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>                  <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>        　　　　　　            <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　            <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span>     　　            <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span>        　　                <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>       　　　　            <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     　　            <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>                  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span>       　　                <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     　　            <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>                    <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>      　　            <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line">      <span class="attr">exec:</span>       　　　　　　        <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]               <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>        　　　　        <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>             <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>       <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　    <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>] <span class="comment">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span>   　　    <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span>      <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>      　　    <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>        　　　　　　    <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     　　 　　    <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;      　　　　    <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>      　　    <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">string</span>      　　        <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">  <span class="attr">secret:</span>       　　　　　　    <span class="comment">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class="line">    <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">    <span class="attr">items:</span>     </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">configMap:</span>      　　　　            <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">items:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>



<h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><img data-src="/2020/08/20/k8s%E8%B0%83%E5%BA%A6%E5%8D%95%E5%85%83Pod/image-20200820142135158.png" class="" title="image-20200820142135158">

<h3 id="Pause容器"><a href="#Pause容器" class="headerlink" title="Pause容器"></a>Pause容器</h3><p>每个Pod里运行着一个特殊的被称之为Pause的容器，其他容器则为用户业务容器，这些业务容器<strong>共享Pause容器的网络栈和Volume挂载卷</strong>，我们可以将一组密切相关的服务进程放入同一个Pod中，这样它们之间仅需通过localhost就能互相通信。</p>
<h3 id="Init-C"><a href="#Init-C" class="headerlink" title="Init C"></a>Init C</h3><p>如果为一个 Pod 指定了多个 Init 容器，这些Init容器会按顺序逐个运行。每个 Init 容器都必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时，Kubernetes 才会为 Pod 初始化应用容器。Init容器可以用来阻塞应用容器直到达到特定条件。</p>
<p>Init容器与普通的容器非常像，除了以下两点：</p>
<ul>
<li><p>Init容器总是运行到成功完成且正常退出为止</p>
</li>
<li><p>只有前一个Init容器成功完成并正常退出，才能运行下一个Init容器</p>
</li>
</ul>
<p>如果Pod的Init容器失败，Kubernetes会不断地重启Pod，直到Init容器成功为止。但如果Pod对应的restartPolicy为Never，则不会重新启动。</p>
<p>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态，该Pod的端口将不会在 Service 中进行聚集。 正在初始化中的 Pod 处于 Pending 状态，但会将条件 Initializing 设置为 true。</p>
<p>如果 Pod 重启，所有 Init 容器必须重新执行。在 Pod 中的每个应用容器和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在校验时抛出错误。</p>
<h3 id="Readiness-amp-Liveness探针"><a href="#Readiness-amp-Liveness探针" class="headerlink" title="Readiness &amp; Liveness探针"></a>Readiness &amp; Liveness探针</h3><p>探针是由kubelet对于容器进行的定期诊断，目前支持三种形式的探针：</p>
<ul>
<li>ExecAction：在容器内执行特定的命令，如果命令退出码为0则代表诊断成功。</li>
<li>TCPSocketAction：对指定的容器IP地址上的TCP端口进行检测，若端口打开，则检测成功。</li>
<li>HTTPGetAction：对指定的端口和路由进行HTTP Get请求，响应状态码大于等于200且小于400则表示成功。</li>
</ul>
<h4 id="ReadinessProbe"><a href="#ReadinessProbe" class="headerlink" title="ReadinessProbe"></a>ReadinessProbe</h4><p>用于检测容器服务是否已就绪，若检测失败，则该Pod对应的Service下的端点列表中不会存在该Pod。</p>
<h4 id="LivenessProbe"><a href="#LivenessProbe" class="headerlink" title="LivenessProbe"></a>LivenessProbe</h4><p>用于检测容器服务是否存活，如果检测失败，kubelet会杀死容器，然后根据restartPolicy操作。</p>
<h3 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h3><p>Pod hook是由Kubernetes管理的kubelet发起的，当容器中的启动/退出之前执行的动作。</p>
<p>Hook的类型包括两种：</p>
<ul>
<li>exec：执行一段命令</li>
<li>HTTP：发送HTTP请求</li>
</ul>
<h4 id="PostStart"><a href="#PostStart" class="headerlink" title="PostStart"></a>PostStart</h4><p>这个回调在创建容器之后立即执行。 但是，不能保证回调会在容器入口点（ENTRYPOINT）之前执行。 没有参数传递给处理程序。</p>
<h4 id="PreStop"><a href="#PreStop" class="headerlink" title="PreStop"></a>PreStop</h4><p>在容器因 API 请求或者管理事件（诸如存活态探针失败、资源抢占、资源竞争等）而被终止之前， 此回调会被调用。 如果容器已经处于终止或者完成状态，则对 preStop 回调的调用将失败。 此调用是阻塞的，也是同步调用，因此必须在删除容器的调用之前完成。 没有参数传递给处理程序。</p>
<h3 id="Pod的相位"><a href="#Pod的相位" class="headerlink" title="Pod的相位"></a>Pod的相位</h3><img data-src="/2020/08/20/k8s%E8%B0%83%E5%BA%A6%E5%8D%95%E5%85%83Pod/image-20200820150924109.png" class="" title="image-20200820150924109">

<table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Pending</code></td>
<td align="center">Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间，</td>
</tr>
<tr>
<td align="center"><code>Running</code></td>
<td align="center">Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td>
</tr>
<tr>
<td align="center"><code>Succeeded</code></td>
<td align="center">Pod 中的所有容器都已成功终止，并且不会再重启。</td>
</tr>
<tr>
<td align="center"><code>Failed</code></td>
<td align="center">Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td>
</tr>
<tr>
<td align="center"><code>Unknown</code></td>
<td align="center">因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s服务发现</title>
    <url>/2020/08/20/k8s%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>Kubernetes中为了实现服务实例间的负载均衡和不同服务间的服务发现，创造了Serivce对象，同时又为从集群外部访问集群创建了Ingress对象。</p>
<a id="more"></a>

<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Kubernetes的Service通过Label Selector选取一组Pod，并为依赖这些Pod的客户端提供负载均衡（轮询方式）服务。</p>
<h3 id="why-Service"><a href="#why-Service" class="headerlink" title="why Service"></a>why Service</h3><p>虽然我们已经可以借助Deployment管理各服务的Pod使其时刻保持一定的副本数，且能实现动态的扩缩容；Pod异常退出后，RS控制器会负责重建一个新的Pod并销毁旧的Pod，控制器也可根据资源使用情况进行Pod实例数的动态增删；但问题在于，在Pod销毁重建和扩缩容前后，Pod的ip总是变化的。对于客户端来说，无法使用一个固定的地址或名称来获取服务Pod的ip列表。</p>
<p>Service提供Pod服务端点的聚合，Service一旦被创建，其ip保持不变；Service可以感知到其关联Pod的增删情况和服务状态，如当有新的Pod被建立且已经Ready时，该Pod的ip地址会被加入到该Service的端点列表中，客户端只需配置Service的固定地址就可实现对Pod的稳定访问。</p>
<img data-src="/2020/08/20/k8s%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20200820163923048.png" class="" title="image-20200820163923048">

<h3 id="Service的类别"><a href="#Service的类别" class="headerlink" title="Service的类别"></a>Service的类别</h3><p>Kubernetes中的Service有以下四种类型：</p>
<ul>
<li><strong>ClusterIP</strong>：默认类型，自动分配一个仅集群内布可以访问的虚拟ip</li>
<li><strong>NodePort</strong>：在Cluster IP的基础上，为Service在每个节点上绑定一个端口，这样就可通过NodeIP:NodePort来访问该服务</li>
<li><strong>LoadBalancer</strong>：在NodePort的基础上，借助云服务供应商（cloud providor）创建一个外部的负载均衡器，并将请求转发至NodePort</li>
<li><strong>ExternalName</strong>：把集群外部的服务引入到集群内部中，在集群内部直接使用，没有任何代理被创建（Kubernetes&gt;= 1.7）</li>
</ul>
<h3 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h3><p>有时不需要或不想要负载均衡，以及单独的 Service IP。遇到这种情况，可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>&quot;None&quot;</code> 来创建 <code>Headless</code> Service。对这类 <code>Service</code> 并不会分配 Cluster IP，kube-proxy 不会处理它们，而且平台也不会为它们进行负载均衡和路由。DNS 如何实现自动配置，依赖于 <code>Service</code> 是否定义了 selector。 </p>
<p>headless service可以通过解析service的DNS,返回所有Pod的地址和DNS(statefulSet部署的Pod才有DNS)；普通的service,只能通过解析service的DNS返回service的ClusterIP。</p>
<h4 id="为什么要用headless-service-statefulSet部署有状态应用"><a href="#为什么要用headless-service-statefulSet部署有状态应用" class="headerlink" title="为什么要用headless service+statefulSet部署有状态应用?"></a>为什么要用headless service+statefulSet部署有状态应用?</h4><p><strong>1.headless service会为关联的Pod分配一个域</strong><br><code>&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code><br><strong>2.StatefulSet会为关联的Pod保持一个不变的Pod Name</strong><br>statefulset中Pod的hostname格式为<code>$(StatefulSet name)-$(pod序号)</code><br><strong>3.StatefulSet会为关联的Pod分配一个dnsName</strong><br><code>$&lt;Pod Name&gt;.$&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code></p>
<h3 id="Service的代理模式"><a href="#Service的代理模式" class="headerlink" title="Service的代理模式"></a>Service的代理模式</h3><p>在 Kubernetes 集群中，每个 Node 运行一个 kube-proxy 进程。kube-proxy 负责为 Service 实现了一种 VIP（虚拟 IP）的形式。</p>
<p>在 Kubernetes v1.0 版本，代理完全在 userspace，Service 是 “4层代理”（TCP/UDP over IP）概念。</p>
<p>在 Kubernetes v1.1 版本，新增了 iptables 代理，但并不是默认的运行模式。新增了 Ingress API（beta 版），用来表示 “7层代理”（HTTP）服务。</p>
<p>从 Kubernetes v1.2 起，默认就是 iptables 代理。</p>
<p>在 Kubernetes v1.8.0-beta.0 中，添加了ipvs代理。</p>
<h4 id="userspace-代理模式"><a href="#userspace-代理模式" class="headerlink" title="userspace 代理模式"></a>userspace 代理模式</h4><img data-src="/2020/08/20/k8s%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20200820181953578.png" class="" title="image-20200820181953578">

<p>这种模式，kube-proxy 会监视 Kubernetes master 对 <code>Service</code> 对象和 <code>Endpoints</code> 对象的添加和移除。 对每个 <code>Service</code>，它会在本地 Node 上打开一个端口（随机选择）。</p>
<p>然后，kube-proxy安装 iptables 规则，捕获到达该 <code>Service</code> 的 <code>clusterIP</code>（是虚拟 IP）和 <code>Port</code> 的请求，并重定向到代理端口，代理端口再代理请求到 backend <code>Pod</code>。</p>
<p>网络返回的结果是，任何到达 <code>Service</code> 的 IP:Port 的请求，都会被代理到一个合适的 backend，不需要客户端知道关于 Kubernetes、<code>Service</code>、或 <code>Pod</code> 的任何信息。</p>
<p>默认的策略是，通过 round-robin 算法来选择 backend <code>Pod</code>。 实现基于客户端 IP 的会话亲和性，可以通过设置 <code>service.spec.sessionAffinity</code> 的值为 <code>&quot;ClientIP&quot;</code> （默认值为 <code>&quot;None&quot;</code>）。</p>
<h4 id="iptables-代理模式"><a href="#iptables-代理模式" class="headerlink" title="iptables 代理模式"></a>iptables 代理模式</h4><img data-src="/2020/08/20/k8s%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20200820182023781.png" class="" title="image-20200820182023781">

<p>这种模式，kube-proxy 会监视 Kubernetes master 对 <code>Service</code> 对象和 <code>Endpoints</code> 对象的添加和移除。 对每个 <code>Service</code>，它会安装 iptables 规则，从而捕获到达该 <code>Service</code> 的 <code>clusterIP</code>（虚拟 IP）和端口的请求，进而将请求直接重定向到 <code>Service</code> 的一组 backend 中的某个上面。对于每个 <code>Endpoints</code> 对象，它也会安装 iptables 规则，这个规则会选择一个 backend <code>Pod</code>。</p>
<p>默认的策略是，随机选择一个 backend。实现基于客户端 IP 的会话亲和性，可以将 <code>service.spec.sessionAffinity</code> 的值设置为 <code>&quot;ClientIP&quot;</code> （默认值为 <code>&quot;None&quot;</code>）。</p>
<p>和 userspace 代理类似，网络返回的结果是，任何到达 <code>Service</code> 的 IP:Port 的请求，都会被代理到一个合适的 backend，不需要客户端知道关于 Kubernetes、<code>Service</code>、或 <code>Pod</code> 的任何信息。</p>
<p>这应该比 userspace 代理更快、更可靠。然而，不像 userspace 代理，如果初始选择的 <code>Pod</code> 没有响应，iptables 代理不能自动地重试另一个 <code>Pod</code>，所以它需要依赖就绪指针。</p>
<h4 id="ipvs-代理模式"><a href="#ipvs-代理模式" class="headerlink" title="ipvs 代理模式"></a>ipvs 代理模式</h4><img data-src="/2020/08/20/k8s%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20200820182056726.png" class="" title="image-20200820182056726">

<p>与iptables类似，ipvs基于netfilter 的 hook 功能，但使用哈希表作为底层数据结构并在内核空间中工作。这意味着ipvs可以更快地重定向流量，并且在同步代理规则时具有更好的性能。此外，ipvs为负载均衡算法提供了更多选项，例如：</p>
<ul>
<li><code>rr</code>：轮询调度</li>
<li><code>lc</code>：最小连接数</li>
<li><code>dh</code>：目标哈希</li>
<li><code>sh</code>：源哈希</li>
<li><code>sed</code>：最短期望延迟</li>
<li><code>nq</code>： 不排队调度</li>
</ul>
<p><strong>注意：</strong> ipvs模式假定在运行kube-proxy之前在节点上都已经安装了IPVS内核模块。当kube-proxy以ipvs代理模式启动时，kube-proxy将验证节点上是否安装了IPVS模块，如果未安装，则kube-proxy将回退到iptables代理模式。</p>
<h3 id="service负载均衡为何不使用-round-robin-DNS？"><a href="#service负载均衡为何不使用-round-robin-DNS？" class="headerlink" title="service负载均衡为何不使用 round-robin DNS？"></a>service负载均衡为何不使用 round-robin DNS？</h3><p>一个不时出现的问题是，为什么我们都使用 VIP 的方式，而不使用标准的 round-robin DNS，有如下几个原因：</p>
<ul>
<li>长久以来，DNS 库都没能认真对待 DNS TTL、缓存域名查询结果</li>
<li>很多应用只查询一次 DNS 并缓存了结果</li>
<li>就算应用和库能够正确查询解析，每个客户端反复重解析造成的负载也是非常难以管理的</li>
</ul>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Kubernetes 支持2种基本的服务发现模式 —— 环境变量和 DNS。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>当 <code>Pod</code> 运行在 <code>Node</code> 上，kubelet 会在Pod上为每个活跃的 <code>Service</code> 添加一组环境变量。 它支持简单的 <code>&#123;SVCNAME&#125;_SERVICE_HOST</code> 和 <code>&#123;SVCNAME&#125;_SERVICE_PORT</code> 变量，这里 <code>Service</code> 的名称需大写，短横线被转换成下划线。</p>
<p>举个例子，一个名称为 <code>&quot;redis-master&quot;</code> 的 Service 暴露了 TCP 端口 6379，同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service 生成了如下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br></pre></td></tr></table></figure>

<p>但这以来Pod和Service建立的顺序 —— <code>Pod</code> 想要通过环境变量访问的任何 <code>Service</code>，必须先创建Service然后创建客户端Pod，否则这些环境变量就不会被赋值。DNS 并没有这个限制。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 服务器监视着创建新 <code>Service</code> 的 Kubernetes API，从而为每一个 <code>Service</code> 创建一组 DNS 记录。如果整个集群的 DNS 一直被启用，那么所有的 <code>Pod</code> 应该能够自动对 <code>Service</code> 进行名称解析。</p>
<p>例如，有一个名称为 <code>&quot;my-service&quot;</code> 的 <code>Service</code>，它在 Kubernetes 集群中名为 <code>&quot;my-ns&quot;</code> 的 <code>Namespace</code> 中，为 <code>&quot;my-service.my-ns&quot;</code> 创建了一条 DNS 记录。</p>
<p>在名称为 <code>&quot;my-ns&quot;</code> 的 <code>Namespace</code> 中的 <code>Pod</code> 应该能够简单地通过名称查询找到 <code>&quot;my-service&quot;</code>。在另一个 <code>Namespace</code> 中的 <code>Pod</code> 必须限定名称为 <code>&quot;my-service.my-ns&quot;</code>。这些名称查询的结果是 Cluster IP。</p>
<p>Kubernetes 也支持对端口名称的 DNS SRV（Service）记录。如果名称为 <code>&quot;my-service.my-ns&quot;</code> 的 <code>Service</code> 有一个名为 <code>&quot;http&quot;</code> 的 <code>TCP</code> 端口，可以对 <code>&quot;_http._tcp.my-service.my-ns&quot;</code> 执行 DNS SRV 查询，得到 <code>&quot;http&quot;</code> 的端口号。</p>
<p>Kubernetes DNS 服务器是唯一的一种能够访问 <code>ExternalName</code> 类型的 Service 的方式。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx虚拟主机原理</title>
    <url>/2020/08/20/nginx%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>启动nginx服务，系统就监听了本机的80端口（本机的所有网卡的80端口），所以只要客户端请求任意一块网卡的IP 80端口，nginx都会响应；客户端请求任意一块网卡ip的80端口，nginx服务都会看请求报文中的host头，如host:<a href="http://www.foo.com/">www.foo.com</a> ，nginx会从nginx.conf配置文件中找于此对应的虚拟主机，按照此主机的相关配置处理请求。</p>
<a id="more"></a>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">[root@web01 ~]# cat nginx.conf</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.foo.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html/www;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  bbs.foo.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html/bbs;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  blog.foo.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html/blog;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，如果客户端访问<a href="http://bbs.foo.com/">http://bbs.foo.com</a> ，nginx会响应主机上的<code> html/bbs/index.html</code>；而如果客户端访问<a href="http://blog.foo.com/">http://blog.foo.com</a> ，那么nginx将响应主机上的<code> html/blog/index.html</code>，这就是虚拟主机的效果。</p>
<p>如果客户端的请求报文中没有虚拟主机名只有一个ip地址，那么nginx服务器只能把nginx.conf配置文件中第一个虚拟主机名作为默认主机名以响应报文的形式发给客户端。也即是如果客户端直接输入nginx的ip地址，那么nginx服务器响应报文的时候默认响应第一个虚拟主机名字给客户端，即响应<code>html/www/index.html</code>。</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 7层代理Ingress</title>
    <url>/2020/08/21/7%E5%B1%82%E4%BB%A3%E7%90%86Ingress/</url>
    <content><![CDATA[<p>Kubernetes的Service对象仅提供了四层转发的功能，在 Kubernetes v1.1 版本新增了Ingress对象以支持七层转发。</p>
<a id="more"></a>

<h2 id="为什么需要Ingress"><a href="#为什么需要Ingress" class="headerlink" title="为什么需要Ingress"></a>为什么需要Ingress</h2><p>使用NodePort类型进行服务暴露的时候，每个Service都需要为其打开一个端口。当Service数量比较多的时候，<strong>端口管理变得困难</strong>。另外，NodePort类型的服务暴露是基于四层代理转发的，<strong>无法根据HTTP的header或者path进行路由转发</strong>。</p>
<h2 id="Ingress资源定义"><a href="#Ingress资源定义" class="headerlink" title="Ingress资源定义"></a>Ingress资源定义</h2><p>Ingress可作为全部服务的总入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure>

<p>我们可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API server的方式来请求ingress。</p>
<p>Ingress资源分为Ingress Controller和Ingress两个部分</p>
<ul>
<li><strong>Ingress Controller</strong>是流量的入口，一般是 一个软件实体，比如<strong>Nginx</strong>或者<strong>HAProxy</strong></li>
<li><strong>Ingress</strong>描述具体的路由规则</li>
</ul>
<p><em>如果没有配置Ingress controller，那么将Ingress资源POST到API server不会有任何用处！！！</em></p>
<p>Ingress Controller会监听API Server上的Ingress资源，并实时生效。简单来说Ingress描述路由规则，而Ingress Controller实时实现这些规则。需要提出的是，<strong>Ingress Controller也是运行于集群中的Pod资源对象，且一般以Deployment管理</strong>。</p>
<h3 id="Ingress-controllers"><a href="#Ingress-controllers" class="headerlink" title="Ingress controllers"></a>Ingress controllers</h3><p>为了使Ingress正常工作，集群中<strong>必须运行Ingress controller</strong>。 这与其他类型的控制器不同，其他类型的控制器通常作为<code>kube-controller-manager</code>二进制文件的一部分运行，在集群启动时自动启动。 你需要选择最适合自己集群的Ingress controller或者自己实现一个。</p>
<ul>
<li>kubernetes当前支持并维护<a href="https://git.k8s.io/ingress-gce/README.md">GCE</a>和<a href="https://git.k8s.io/ingress-nginx/README.md">nginx</a>两种controller.</li>
<li>F5（公司）<a href="https://support.f5.com/csp/article/K86859508">支持并维护</a> <a href="http://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest">F5 BIG-IP Controller for Kubernetes</a>.</li>
<li><a href="https://konghq.com/">Kong</a> 同时支持并维护<a href="https://discuss.konghq.com/c/kubernetes">社区版</a>与<a href="https://konghq.com/api-customer-success/">企业版</a>的 <a href="https://konghq.com/blog/kubernetes-ingress-controller-for-kong/">Kong Ingress Controller for Kubernetes</a>.</li>
<li><a href="https://github.com/containous/traefik">Traefik</a> 是功能齐全的 ingress controller(<a href="https://letsencrypt.org/">Let’s Encrypt</a>, secrets, http2, websocket…), <a href="https://containo.us/services">Containous</a> 也对其提供商业支持。</li>
<li><a href="https://istio.io/">Istio</a> 使用CRD Gateway来<a href="https://istio.io/docs/tasks/traffic-management/ingress/">控制Ingress流量</a>。</li>
</ul>
<p>Ingress控制器自身运行于Pod中的容器应用，一般是<strong>Nginx</strong>或者<strong>Envoy</strong>一类的具有代理和负载均衡功能的守护进程，它监视着来自于API Server的Ingress对象状态，并以其规则生成相应的应用程序专用格式的配置文件并重载或重启守护进程而使新配置生效。如何让Ingress控制器接收外部流量呢？</p>
<p>（1）以<strong>Deployment</strong>控制器管理Ingress控制器的Pod资源，并通过<strong>NodePort</strong>或者LoadBalancer类型的<strong>Service</strong>对象为其接入集群外部的请求流量</p>
<p>（2）借助于<strong>DaemonSet</strong>控制器，将Ingress控制器的Pod资源各自以单一实例的方式运行于集群的工作节点，并配置这类Pod对象以<strong>hostPort</strong>或<strong>hostNetwork</strong>的方式接入外部请求流量</p>
<p>将Ingress Nginx控制器暴露到外部服务（假设为nginx控制器，且包含标签 app: ingress-nginx）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line"> name: nginx-ingress-controller</span><br><span class="line"> namespace: ingress-nginx</span><br><span class="line">spec:</span><br><span class="line"> type: NodePort</span><br><span class="line"> ports:</span><br><span class="line"> - port: 80</span><br><span class="line">   name: http</span><br><span class="line"> - port: 443</span><br><span class="line">   name: https</span><br><span class="line"> selector:</span><br><span class="line">  app: ingress-nginx</span><br></pre></td></tr></table></figure>

<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><h4 id="单Service的Ingress"><a href="#单Service的Ingress" class="headerlink" title="单Service的Ingress"></a>单Service的Ingress</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">testsvc</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl create -f</code>命令创建，然后查看ingress：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get ing</span><br><span class="line">NAME                RULE          BACKEND        ADDRESS</span><br><span class="line"><span class="built_in">test</span>-ingress        -             testsvc:80     107.178.254.228</span><br></pre></td></tr></table></figure>

<p><code>107.178.254.228</code>就是Ingress controller为了实现Ingress而分配的IP地址。<code>RULE</code>列表示所有发送给该IP的流量都被转发到了<code>BACKEND</code>所列的Kubernetes service上。</p>
<h4 id="分发多个Service"><a href="#分发多个Service" class="headerlink" title="分发多个Service"></a>分发多个Service</h4><p>假如你想要创建这样的一个设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.bar.com -&gt; 178.91.123.132 -&gt; &#x2F; foo    s1:80</span><br><span class="line">                                 &#x2F; bar    s2:80</span><br></pre></td></tr></table></figure>

<p>你需要一个这样的ingress：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bar</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s2</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl create -f</code>创建完ingress后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get ing</span><br><span class="line">NAME      RULE          BACKEND   ADDRESS</span><br><span class="line"><span class="built_in">test</span>      -</span><br><span class="line">          foo.bar.com</span><br><span class="line">          /foo          s1:80</span><br><span class="line">          /bar          s2:80</span><br></pre></td></tr></table></figure>

<p>只要服务（s1，s2）存在，Ingress controller就会将提供一个满足该Ingress的特定loadbalancer实现。 这一步完成后，您将在Ingress的最后一列看到loadbalancer的地址。</p>
<h4 id="基于名称的虚拟主机"><a href="#基于名称的虚拟主机" class="headerlink" title="基于名称的虚拟主机"></a>基于名称的虚拟主机</h4><p>Name-based的虚拟主机在同一个IP地址下拥有多个主机名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.bar.com --|                 |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132  |</span><br><span class="line">bar.foo.com --|                 |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></figure>

<p>下面这个ingress说明基于<code>Host header</code>的后端loadbalancer的路由请求：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bar.foo.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s2</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>默认backend</strong>：一个没有rule的ingress，如前面章节中所示，所有流量都将发送到一个默认backend。</p>
<h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>你可以通过指定包含TLS私钥和证书的<code>secret</code>来加密Ingress：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">tls.crt:</span> <span class="string">base64</span> <span class="string">encoded</span> <span class="string">cert</span></span><br><span class="line">  <span class="attr">tls.key:</span> <span class="string">base64</span> <span class="string">encoded</span> <span class="string">key</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">testsecret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br></pre></td></tr></table></figure>

<p>在Ingress中引用这个secret将通知Ingress controller使用TLS加密从将客户端到loadbalancer的channel：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="literal">no</span><span class="string">-rules-map</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">secretName:</span> <span class="string">testsecret</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>ConfigMap</title>
    <url>/2020/08/24/ConfigMap/</url>
    <content><![CDATA[<p>许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。这些配置信息需要与docker image解耦。ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。</p>
<a id="more"></a>

<h2 id="ConfigMap的创建"><a href="#ConfigMap的创建" class="headerlink" title="ConfigMap的创建"></a>ConfigMap的创建</h2><p><em>忘记命令时记得随时<code>kubectl create configmap -h</code>。</em></p>
<h3 id="使用目录创建"><a href="#使用目录创建" class="headerlink" title="使用目录创建"></a>使用目录创建</h3><p>比如我们已经有了一些配置文件，其中包含了我们想要设置的ConfigMap的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls configmap</span><br><span class="line">foo.properties</span><br><span class="line">bar.properties</span><br><span class="line"></span><br><span class="line">$ cat configmap/foo.properties</span><br><span class="line">abc=123</span><br><span class="line"></span><br><span class="line">$ cat configmap/bar.properties</span><br><span class="line">xyz=456</span><br></pre></td></tr></table></figure>

<p>使用下面的命令可以创建一个包含目录中所有文件的ConfigMap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create configmap my-config --from-file=configmap</span><br></pre></td></tr></table></figure>

<p><code>—from-file</code>指定在目录下的所有文件都会被用在ConfigMap里面创建一个键值对，键的名字就是文件名，值就是文件的内容。</p>
<p>可以使用describe或get -o yaml的方式查看创建的资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe configmaps my-config</span><br><span class="line">// kubectl get configmaps my-config -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:         my-config</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">foo.properties:</span><br><span class="line">----</span><br><span class="line">abc=123</span><br><span class="line"></span><br><span class="line">bar.properties:</span><br><span class="line">----</span><br><span class="line">xyz=456</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>



<h3 id="使用单个文件创建"><a href="#使用单个文件创建" class="headerlink" title="使用单个文件创建"></a>使用单个文件创建</h3><p>刚才<strong>使用目录创建</strong>的时候我们<code>—from-file</code>指定的是一个目录，只要指定为一个文件就可以从单个文件中创建ConfigMap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create configmap foo-config --from-file=configmap/foo.properties </span><br><span class="line"></span><br><span class="line">$ kubectl get configmaps foo-config -o yaml</span><br></pre></td></tr></table></figure>

<p><code>—from-file</code>这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的。</p>
<h3 id="使用字面量创建"><a href="#使用字面量创建" class="headerlink" title="使用字面量创建"></a>使用字面量创建</h3><p>使用文字值创建，利用<code>—from-literal</code>参数传递配置信息，该参数可以使用多次，格式如下；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm</span><br><span class="line"></span><br><span class="line">$ kubectl get configmaps special-config -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  special.how: very</span><br><span class="line">  special.type: charm</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2020-08-24T02:13:37Z&quot;</span></span><br><span class="line">  name: special-config</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: <span class="string">&quot;1015532&quot;</span></span><br><span class="line">  selfLink: /api/v1/namespaces/default/configmaps/special-config</span><br><span class="line">  uid: 0533b623-0049-4fef-bc79-8091f6f0d4b2</span><br></pre></td></tr></table></figure>

<h2 id="ConfigMap在Pod中的应用"><a href="#ConfigMap在Pod中的应用" class="headerlink" title="ConfigMap在Pod中的应用"></a>ConfigMap在Pod中的应用</h2><h3 id="映射为环境变量"><a href="#映射为环境变量" class="headerlink" title="映射为环境变量"></a>映射为环境变量</h3><p>ConfigMap可以被用来填入环境变量。看下下面的ConfigMap。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">special.how:</span> <span class="string">very</span></span><br><span class="line">  <span class="attr">special.type:</span> <span class="string">charm</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">env-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">log_level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<p>我们可以在Pod中这样使用ConfigMap：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span> ]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_TYPE_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.type</span></span><br><span class="line">      <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">env-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>这个Pod运行后会输出如下几行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SPECIAL_LEVEL_KEY=very</span><br><span class="line">SPECIAL_TYPE_KEY=charm</span><br><span class="line">log_level=INFO</span><br></pre></td></tr></table></figure>

<h3 id="作为命令行参数"><a href="#作为命令行参数" class="headerlink" title="作为命令行参数"></a>作为命令行参数</h3><p>为了将ConfigMap中的值注入到命令行的参数里面，我们还要像前面那个例子一样使用环境变量替换语法<code>$&#123;VAR_NAME)</code>。（其实这个东西就是给Docker容器设置环境变量，以前我创建镜像的时候经常这么玩，通过docker run的时候指定-e参数修改镜像里的环境变量，然后docker的CMD命令再利用该$(VAR_NAME)通过sed来修改配置文件或者作为命令行启动参数。）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&quot;</span> ]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_TYPE_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.type</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<h3 id="映射为Volume"><a href="#映射为Volume" class="headerlink" title="映射为Volume"></a>映射为Volume</h3><p>可以将ConfigMap的键值对映射为Volume并挂载进Pod，key被映射为文件名，value被映射为文件内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat /etc/config/special.how&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>运行这个Pod的输出是<code>very</code>。</p>
<p>我们也可以在ConfigMap值被映射的数据卷里控制路径。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;cat /etc/config/path/to/special-key&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">path/to/special-key</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>运行这个Pod后的结果是<code>very</code>。</p>
<h2 id="ConfigMap的热更新"><a href="#ConfigMap的热更新" class="headerlink" title="ConfigMap的热更新"></a>ConfigMap的热更新</h2><p>直接上结论，更新 ConfigMap 后：</p>
<ul>
<li>使用该 ConfigMap 挂载的 Env <strong>不会</strong>同步更新</li>
<li>使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间（实测大概10秒）才能同步更新</li>
</ul>
<p>ENV 是在容器启动的时候注入的，启动之后 kubernetes 就不会再改变环境变量的值，且同一个 namespace 中的 pod 的环境变量是不断累加的。</p>
<h4 id="ConfigMap-更新后滚动更新-Pod"><a href="#ConfigMap-更新后滚动更新-Pod" class="headerlink" title="ConfigMap 更新后滚动更新 Pod"></a>ConfigMap 更新后滚动更新 Pod</h4><p>更新 ConfigMap 目前并不会触发相关 Pod 的滚动更新，可以通过修改 pod annotations 的方式强制触发滚动更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl patch deployment my-nginx --patch <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;: &#123;&quot;version/config&quot;: &quot;20180411&quot; &#125;&#125;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个例子里我们在 <code>.spec.template.metadata.annotations</code> 中添加 <code>version/config</code>，每次通过修改 <code>version/config</code> 来触发滚动更新。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Secret</title>
    <url>/2020/08/24/Secret/</url>
    <content><![CDATA[<p>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用。</p>
<a id="more"></a>

<p>Secret有三种类型：</p>
<ul>
<li><strong>Service Account</strong> ：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的<code>/run/secrets/kubernetes.io/serviceaccount</code>目录中；</li>
<li><strong>Opaque</strong> ：base64编码格式的Secret，用来存储密码、密钥等；</li>
<li><strong>kubernetes.io/dockerconfigjson</strong> ：用来存储私有docker registry的认证信息。</li>
</ul>
<h2 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a><strong>Service Account</strong></h2><p>Service Account用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的<code>/run/secrets/kubernetes.io/serviceaccount</code>目录中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwli@DESKTOP-4I3FV9S:/mnt/c/Users/pwli$ kubectl run nginx --image nginx</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed <span class="keyword">in</span> a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"></span><br><span class="line">pwli@DESKTOP-4I3FV9S:/mnt/c/Users/pwli$ kubectl get pod</span><br><span class="line">NAME                     READY   STATUS      RESTARTS   AGE</span><br><span class="line">dapi-test-pod            0/1     Completed   0          33m</span><br><span class="line">nginx-6db489d4b7-pwxq8   1/1     Running     0          44s</span><br><span class="line"></span><br><span class="line">pwli@DESKTOP-4I3FV9S:/mnt/c/Users/pwli$ kubectl <span class="built_in">exec</span> nginx-6db489d4b7-pwxq8 -it -- ls /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">ca.crt  namespace  token</span><br></pre></td></tr></table></figure>

<h2 id="Opaque"><a href="#Opaque" class="headerlink" title="Opaque"></a>Opaque</h2><p>Opaque类型的数据是一个map类型，要求value是base64编码格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;admin&quot;</span> | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;1f2d1e2e67df&quot;</span> | base64</span><br><span class="line">MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure>

<p>secrets.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MWYyZDFlMmU2N2Rm</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br></pre></td></tr></table></figure>

<p>接着，就可以创建secret了：<code>kubectl create -f secrets.yml</code>。</p>
<p>创建好secret之后，有两种方式来使用它：</p>
<ul>
<li>以Volume方式挂载</li>
<li>以环境变量方式</li>
</ul>
<h3 id="以Volume方式挂载"><a href="#以Volume方式挂载" class="headerlink" title="以Volume方式挂载"></a>以Volume方式挂载</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/my_project_id/pg:v1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;/etc/secrets&quot;</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cp</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">5432</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">5432</span></span><br></pre></td></tr></table></figure>

<h3 id="以环境变量方式挂载"><a href="#以环境变量方式挂载" class="headerlink" title="以环境变量方式挂载"></a>以环境变量方式挂载</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wordpress-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">        <span class="attr">visualize:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;wordpress&quot;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&quot;wordpress&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_USER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<h2 id="dockerconfigjson"><a href="#dockerconfigjson" class="headerlink" title="dockerconfigjson"></a>dockerconfigjson</h2><p><strong>kubernetes.io/dockerconfigjson</strong>用来表示私有Docker仓库的认证信息，可以直接用<code>kubectl</code>命令来创建用于docker registry认证的secret：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl create secret docker-registry myregistrykey --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL</span><br><span class="line">secret <span class="string">&quot;myregistrykey&quot;</span> created.</span><br></pre></td></tr></table></figure>

<p>也可以直接读取<code>~/.docker/config.json</code>的内容来创建：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat ~/.docker/config.json | base64</span><br><span class="line">$ cat &gt; myregistrykey.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: myregistrykey</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==</span><br><span class="line"><span class="built_in">type</span>: kubernetes.io/dockerconfigjson</span><br><span class="line">EOF</span><br><span class="line">$ kubectl create -f myregistrykey.yaml</span><br></pre></td></tr></table></figure>

<p>在创建Pod的时候，通过<code>imagePullSecrets</code>来引用刚创建的<code>myregistrykey</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">fooapp:v1</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s调度过程</title>
    <url>/2020/08/25/k8s%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Scheduler是Kubernetes的调度器，负责把定义的Pod分配到集群的节点上，Scheduler启动之后持续监听API Server，获取<code>Pod.spec.NodeName</code>为空的Pod，从集群中选择一个合适的节点并将Pod创建在该节点上。</p>
<a id="more"></a>

<p>Pod的调度需要考虑以下几点：</p>
<ul>
<li>公平：保证各节点资源均衡分配</li>
<li>资源高效利用：集群资源利用率最大化</li>
<li>效率：调度的性能要好，能较快的完成大量Pod的调度工作</li>
<li>灵活：允许用户根据自己定制的逻辑进行调度</li>
</ul>
<h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><p>调度分为两个阶段，如果任何过程出错则直接返回错误：</p>
<ul>
<li><strong>predicate阶段</strong>： 过滤掉不满足条件的节点</li>
<li><strong>priority阶段</strong>：对通过的节点按照优先级进行排序，从中选择优先级最高的节点。</li>
</ul>
<p>Predicate阶段有一些列的算法可用：</p>
<ul>
<li>PodFitsResource：节点上剩余的资源是否大于Pod请求的资源</li>
<li>FodFitsHost：如果Pod指定了NodeName，检查节点名称是否和NodeName冲突</li>
<li>PodFitsHostPorts：节点上已使用的port是否和Pod申请的port冲突</li>
<li>PodSelectorMatches：过滤掉和Pod指定的label不匹配的节点</li>
<li>NoDiskConflict：已经mount的volume和Pod指定的volume不冲突，除非他们都是只读</li>
</ul>
<p>如果predicate阶段没有找到合适的节点，Pod会一直在<code>pending</code>状态，不断重试调度，直到有节点满足条件。如果predicate阶段过滤后有多个节点满足条件，就会继续priority阶段，对各节点按照优先级进行排序。</p>
<p>优先级由一系列的键值对组成，键是该优先级项的名称，值是它的权重，这些优先级键包括：</p>
<ul>
<li>LeastRequestedPriority：通过计算CPU和Memory的使用率来决定权重，使用率越低权重越高，即倾向于资源使用比例更低的节点</li>
<li>BalancedResourceAllocation：节点上CPU和Memory使用率越接近，权重越高。改键应和上一条联合使用，不应单独使用</li>
<li>ImageLocalityPriority：倾向于已经存在要使用镜像的节点。</li>
</ul>
<p>通过算法对所有的优先级项目和权重进行计算，得出最终的结果。</p>
<h2 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h2><p>亲和性表示Pod和Pod/Node之间关系的亲密程度，Pod的亲和性可分为节点亲和性、Pod亲和性及Pod反亲和性。</p>
<img data-src="/2020/08/25/k8s%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/image-20200825162257051.png" class="" title="image-20200825162257051">

<p>亲和性/反亲和性可分为软策略和硬策略两种：</p>
<ul>
<li>preferredDuringSchedulingIgnoredDuringExecution：软策略</li>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬策略</li>
</ul>
<h3 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h3><p>pod.spec.affinity.nodeAntiAffinity</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metedata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAntiAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">NotIn</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-node02</span></span><br></pre></td></tr></table></figure>

<h3 id="Pod亲和性"><a href="#Pod亲和性" class="headerlink" title="Pod亲和性"></a>Pod亲和性</h3><p>pod.spec.affinity.podAffinity</p>
<h3 id="Pod反亲和性"><a href="#Pod反亲和性" class="headerlink" title="Pod反亲和性"></a>Pod反亲和性</h3><p>pod.spec.affinity.podAntiAffinity</p>
<p>亲和性/反亲和性调度策略对比：</p>
<table>
<thead>
<tr>
<th>调度策略</th>
<th>匹配标签</th>
<th>操作符</th>
<th>拓扑域支持</th>
<th>调度目标</th>
</tr>
</thead>
<tbody><tr>
<td>nodeAffinity</td>
<td>主机</td>
<td>In, NotIn, Exists, DoesNotExsist, Gt, Lt</td>
<td>否</td>
<td>指定主机</td>
</tr>
<tr>
<td>podAffinity</td>
<td>Pod</td>
<td>In, NotIn, Exists, DoesNotExsist</td>
<td>是</td>
<td>Pod与指定Pod在同一拓扑域</td>
</tr>
<tr>
<td>podAntiAffinity</td>
<td>Pod</td>
<td>In, NotIn, Exists, DoesNotExsist</td>
<td>是</td>
<td>Pod与指定Pod不在同一拓扑域</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metedata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-topo-cn</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-topo-cn</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-topo-cn</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">pod-topo-cn</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">pod-topo-us</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>



<h2 id="Taint-污点"><a href="#Taint-污点" class="headerlink" title="Taint/污点"></a>Taint/污点</h2><p>污点使节点能够排斥一类特定的Pod，除非Pod被指定了<code>toleration</code>的标签。（<code>taint</code>即污点，Node被打上污点；只有容忍[toleration]这些污点的Pod才可能被调度到该Node）。</p>
<h3 id="污点使用"><a href="#污点使用" class="headerlink" title="污点使用"></a>污点使用</h3><p>使用<code>kubectl taint</code>命令可以给某个Node节点设置污点，Node被设置上污点之后就和Pod之间存在了一种互斥的关系，可以让Node拒绝将Pod调度到该Node，甚至将Node上已存在的Pod驱逐出去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给节点增加一个taint，它的key是&lt;key&gt;，value是&lt;value&gt;，effect是NoSchedule。</span></span><br><span class="line">kubectl taint nodes &lt;node_name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br></pre></td></tr></table></figure>

<p>只有拥有和这个<code>taint</code>相匹配的<code>toleration</code>的pod才能够被分配到 <code>node_name</code> 这个节点。</p>
<h2 id="Tolerations-容忍"><a href="#Tolerations-容忍" class="headerlink" title="Tolerations/容忍"></a>Tolerations/容忍</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="effect的类型"><a href="#effect的类型" class="headerlink" title="effect的类型"></a>effect的类型</h3><ul>
<li><p><code>NoSchedule</code>：只有拥有和这个 taint 相匹配的 toleration 的 pod 才能够被分配到这个节点。</p>
</li>
<li><p><code>PreferNoSchedule</code>：系统会<em>尽量</em>避免将 pod 调度到存在其不能容忍 taint 的节点上，但这不是强制的。</p>
</li>
<li><p><code>NoExecute</code> ：任何不能忍受这个 taint 的 pod 都会马上被驱逐，任何可以忍受这个 taint 的 pod 都不会被驱逐。Pod可指定属性 <code>tolerationSeconds</code> 的值，表示pod 还能继续在节点上运行的时间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key1&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基于taint驱逐"><a href="#基于taint驱逐" class="headerlink" title="基于taint驱逐"></a>基于taint驱逐</h3><p>effect 值 <code>NoExecute</code> ，它会影响已经在节点上运行的 pod，即根据策略对Pod进行驱逐。</p>
<ul>
<li>如果 pod 不能忍受effect 值为 <code>NoExecute</code> 的 taint，那么 pod 将马上被驱逐</li>
<li>如果 pod 能够忍受effect 值为 <code>NoExecute</code> 的 taint，但是在 toleration 定义中没有指定 <code>tolerationSeconds</code>，则 pod 还会一直在这个节点上运行。</li>
<li>如果 pod 能够忍受effect 值为 <code>NoExecute</code> 的 taint，而且指定了 <code>tolerationSeconds</code>，则 pod 还能在这个节点上继续运行这个指定的时间长度。</li>
</ul>
<h3 id="污点和容忍的匹配规则"><a href="#污点和容忍的匹配规则" class="headerlink" title="污点和容忍的匹配规则"></a>污点和容忍的匹配规则</h3><p>一个 toleration 和一个 taint 相“匹配”是指它们有一样的 key 和 effect ，并且：</p>
<ul>
<li>如果 <code>operator</code> 是 <code>Exists</code> （此时 toleration 不能指定 <code>value</code>）</li>
<li>如果 <code>operator</code> 是 <code>Equal</code> ，则它们的 <code>value</code> 应该相等</li>
</ul>
<p><strong>特殊情况：</strong></p>
<ul>
<li><p>如果一个 toleration 的 <code>key</code> 为空且 operator 为 <code>Exists</code> ，表示这个 toleration 与任意的 key 、 value 和 effect 都匹配，即这个 toleration 能容忍任意 taint。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个 toleration 的 <code>effect</code> 为空，则 <code>key</code> 值与之相同的相匹配 taint 的 <code>effect</code> 可以是任意值。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="指定调度节点"><a href="#指定调度节点" class="headerlink" title="指定调度节点"></a>指定调度节点</h2><h3 id="指定NodeName"><a href="#指定NodeName" class="headerlink" title="指定NodeName"></a>指定NodeName</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node-01</span>  <span class="comment"># 直接指定node</span></span><br></pre></td></tr></table></figure>

<h3 id="指定Node的标签"><a href="#指定Node的标签" class="headerlink" title="指定Node的标签"></a>指定Node的标签</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">disktype:</span> <span class="string">ssd</span>    <span class="comment"># 对应Node的Label</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s问题清单</title>
    <url>/2020/08/26/k8s%E9%97%AE%E9%A2%98%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<p>记录k8s学习中的疑问</p>
<a id="more"></a>

<ol>
<li>直接修改ReplicationController的pod template的标签会怎样？</li>
<li>ReplicationController接收到一个pod删除的事件，不是立即对该删除事件做响应，而是去查询Pod的当前状态，从而做出对应的响应，这属于水平触发还是边缘触发？</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile最佳实践golang版</title>
    <url>/2020/09/07/Dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5golang%E7%89%88/</url>
    <content><![CDATA[<p>解决运行容器<code>standard_init_linux.go:211: exec user process caused &quot;no such file or directory</code>报错问题，解决容器时区和证书问题，并大幅减小镜像体积。</p>
<a id="more"></a>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 golang:1.14-alpine 作为编译环境，这是体积最小的golang编译环境</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.14</span>-alpine as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache ca-certificates tzdata upx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./go.mod ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./go.sum ./</span></span><br><span class="line"><span class="comment"># 先复制 go.mod 和 go.sum ，然后 go mod download，是为了防止每次构建都会重新下载依赖包，利用docker构建缓存提升构建速度</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="comment"># go build 时加上 -ldflags &quot;-s -w&quot; 去除构建包的调试信息，减小go构建后程序体积，大概减小 1/4</span></span><br><span class="line"><span class="comment"># go build 是默认启用 CGO 的(go env CGO_ENABLED)，在 CGO 开启情况下，无论代码有没有用CGO，都会有库依赖文件</span></span><br><span class="line"><span class="comment"># 这里手动指定关闭CGO</span></span><br><span class="line"><span class="comment"># 使用 upx 压缩,进一步减小体积(但会增加构建时长)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 go build -ldflags <span class="string">&quot;-s -w&quot;</span> -o server &amp;&amp; \</span></span><br><span class="line"><span class="bash">    upx --best server -o _upx_server &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv -f _upx_server server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用了多阶段构建，也就是 FROM XXX as xxx ，在构建程序包的时候，使用带编译环境的镜像去构建</span></span><br><span class="line"><span class="comment"># 运行的时候其实完全不需要go的编译环境，所以在运行阶段使用较小的alpine去运行</span></span><br><span class="line"><span class="keyword">FROM</span> alpine as runner</span><br><span class="line"><span class="comment"># 解决时区和证书问题</span></span><br><span class="line"><span class="comment"># 在 builder 阶段，安装了 ca-certificates tzdata 两个库，在runner阶段，将时区配置和根证书复制了一份</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /usr/src/app/server /opt/app/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8085</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/opt/app/server&quot;</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于k8s服务获取真实客户端ip</title>
    <url>/2020/09/07/%E5%85%B3%E4%BA%8Ek8s%E6%9C%8D%E5%8A%A1%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E5%AE%A2%E6%88%B7%E7%AB%AFip/</url>
    <content><![CDATA[<p>当<code>kube-proxy</code>使用<code>iptables</code>模式，会使用NAT技术映射端口号，所以在后端Pod中只能看到一个假的内部IP而非真实的客户端IP。</p>
<a id="more"></a>

<p>在k8s服务负载均衡的实现（<code>kube-proxy</code>）中，目标容器不能获取真实的客户端ip。要想获取到客户端的真实ip，可以修改service的<code>service.spec.externalTrafficPolicy</code> 字段，该字段表示服务是想要路由到本地节点还是集群级别的端点上，有两个可用选项：<code>Cluster</code> 和<code>Local</code>：</p>
<ul>
<li><p><strong>“Cluster” traffic policy</strong></p>
<p>Cluster模式使得后端pod获取不到真实的客户端ip，因为kube-proxy使用了NAT技术。该模式还可能存在冗余的跳转，如节点A和节点B都有后端pod，客户端通过节点B的NodePort类型的Service访问后端pod，此时存在数据包被路由至Service的ClusterIP，<code>kube-proxy</code>设置的转发规则负责将数据包随机转发到一个后端pod上，最终该数据包被路由到了节点A的后端pod上（绕路了…）。该模式下各后端pod被选中的几率相等，有好的总体负载分布。</p>
</li>
<li><p><strong>“Local” traffic policy</strong></p>
<p>Local模式可以保留客户端源IP，并避免了LoadBalancer和NodePort类型服务的第二跳，但存在潜在的流量分布不平衡的风险（如节点A上1个后端pod，节点B上2个后端pod时，外部负载均衡器只保证平均分配流量给各节点，最终导致节点A上的pod负载偏高）。</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8765</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>



<p><strong>Reference：</strong></p>
<ol>
<li><a href="https://stackoverflow.com/questions/50585616/kubernetes-metallb-traefik-how-to-get-real-client-ip">https://stackoverflow.com/questions/50585616/kubernetes-metallb-traefik-how-to-get-real-client-ip</a></li>
<li><a href="https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip">https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip</a></li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>易忽略的Golang编码规范</title>
    <url>/2020/09/14/%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>自己易忽略的一些规范</p>
<a id="more"></a>

<ul>
<li><h3 id="Interface-合理性验证"><a href="#Interface-合理性验证" class="headerlink" title="Interface 合理性验证"></a>Interface 合理性验证</h3></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>关于Mutex</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex <span class="comment">// only for unexported types（仅适用于非导出类型）</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="Channel-的-size-要么是-1，要么是无缓冲的"><a href="#Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="Channel 的 size 要么是 1，要么是无缓冲的"></a>Channel 的 size 要么是 1，要么是无缓冲的</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="枚举从-1-开始"><a href="#枚举从-1-开始" class="headerlink" title="枚举从 1 开始"></a>枚举从 1 开始</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure>

<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
</li>
</ul>
<ul>
<li><p><strong>Errors返回形式</strong></p>
<ul>
<li><p>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 足够了。</p>
</li>
<li><p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li><p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="https://github.com/xxjwxc/uber_go_guide_cn#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">section on error wrapping</a> 部分的内容。</p>
</li>
<li><p>否则 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 就可以了。</p>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a>，请使用一个错误变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您有可能需要客户端检测的错误，并且想向其中<strong>添加更多信息</strong>（例如，它不是静态字符串），则应使用自定义类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;file %q not found&quot;</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">&quot;testfile.txt&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开<strong>匹配器</strong>功能以检查错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(&amp;quot;file %q not found&amp;quot;, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(&amp;quot;foo&amp;quot;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(&amp;quot;unknown error&amp;quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Atomic</strong></p>
<p>使用 <a href="https://golang.org/pkg/sync/atomic/">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Slice </p>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-swagger入门</title>
    <url>/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文详细介绍go-swagger 通过注解生成swagger spec的使用。</p>
<a id="more"></a>

<p>相比<a href="https://github.com/swaggo/swag">Swag</a>，<a href="https://github.com/go-swagger/go-swagger">go-swagger</a>具有更强大和丰富的功能，go-swagger支持Design First和Code First两种模式，其中Design First是指先定义接口swagger.json，根据接口自动生成代码；Code First是指先编写代码和注解，再自动生成swagger.json文件。本文只介绍Code First模式的常规使用。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">download_url=$(curl -s https://api.github.com/repos/go-swagger/go-swagger/releases/latest | \</span><br><span class="line">  jq -r <span class="string">&#x27;.assets[] | select(.name | contains(&quot;&#x27;</span><span class="string">&quot;<span class="subst">$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span><span class="string">&#x27;_amd64&quot;)) | .browser_download_url&#x27;</span>)</span><br><span class="line">curl -o /usr/<span class="built_in">local</span>/bin/swagger -L<span class="string">&#x27;#&#x27;</span> <span class="string">&quot;<span class="variable">$download_url</span>&quot;</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/swagger</span><br></pre></td></tr></table></figure>

<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/go-swagger/go-swagger/cmd/swagger</span><br></pre></td></tr></table></figure>



<h2 id="swagger-工具使用"><a href="#swagger-工具使用" class="headerlink" title="swagger 工具使用"></a>swagger 工具使用</h2><h3 id="generate-spec"><a href="#generate-spec" class="headerlink" title="generate spec"></a>generate spec</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swagger generate spec -<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">  swagger [OPTIONS] generate spec [spec-OPTIONS]</span><br><span class="line"></span><br><span class="line">generate a swagger spec document from a go application</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -q, --quiet                  silence logs</span><br><span class="line">      --<span class="built_in">log</span>-output=LOG-FILE    redirect logs to file</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>                   Show this <span class="built_in">help</span> message</span><br><span class="line"></span><br><span class="line">[spec <span class="built_in">command</span> options]</span><br><span class="line">      -w, --work-dir=          the base path to use (default: .) <span class="comment"># 指定工作目录，默认为当前目录</span></span><br><span class="line">      -t, --tags=              build tags</span><br><span class="line">      -m, --scan-models        includes models that were annotated with <span class="string">&#x27;swagger:model&#x27;</span></span><br><span class="line">          --compact            when present, doesn<span class="string">&#x27;t prettify the json # 压缩json缩进,不美化格式</span></span><br><span class="line"><span class="string">      -o, --output=            the file to write to  # 输出文件位置</span></span><br><span class="line"><span class="string">      -i, --input=             the file to use as input</span></span><br><span class="line"><span class="string">      -c, --include=           include packages matching pattern</span></span><br><span class="line"><span class="string">      -x, --exclude=           exclude packages matching pattern</span></span><br><span class="line"><span class="string">          --include-tag=       include routes having specified tags (can be specified many times)</span></span><br><span class="line"><span class="string">          --exclude-tag=       exclude routes having specified tags (can be specified many times)</span></span><br><span class="line"><span class="string">          --exclude-deps       exclude all dependencies of project</span></span><br></pre></td></tr></table></figure>

<p>一般只需提前cd只main.go所在目录，然后执行<code> swagger generate spec -o swagger.json</code>即可。</p>
<p>swagger会从main.go开始，借助golang的抽象语法树遍历我们的代码，找到格式匹配的注解并转换成相应的swagger spec。</p>
<h3 id="swagger-serve"><a href="#swagger-serve" class="headerlink" title="swagger serve"></a>swagger serve</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swagger serve -<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">  swagger [OPTIONS] serve [serve-OPTIONS]</span><br><span class="line"></span><br><span class="line">serve a spec and swagger or redoc documentation ui</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -q, --quiet                         silence logs</span><br><span class="line">      --<span class="built_in">log</span>-output=LOG-FILE           redirect logs to file</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>                          Show this <span class="built_in">help</span> message</span><br><span class="line"></span><br><span class="line">[serve <span class="built_in">command</span> options]</span><br><span class="line">          --base-path=                the base path to serve the spec and UI at</span><br><span class="line">      -F, --flavor=[redoc|swagger]    the flavor of docs, can be swagger or redoc (default: redoc) <span class="comment"># 渲染风格，redoc和swagger两种</span></span><br><span class="line">          --doc-url=                  override the url <span class="built_in">which</span> takes a url query param to render the doc ui</span><br><span class="line">          --no-open                   when present won<span class="string">&#x27;t open the the browser to show the url</span></span><br><span class="line"><span class="string">          --no-ui                     when present, only the swagger spec will be served</span></span><br><span class="line"><span class="string">          --flatten                   when present, flatten the swagger spec before serving it</span></span><br><span class="line"><span class="string">      -p, --port=                     the port to serve this site [$PORT]</span></span><br><span class="line"><span class="string">          --host=                     the interface to serve this site, defaults to 0.0.0.0 [$HOST]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>swagger serve 用于根据上一布生成的swagger.json，渲染出可用于交互的html页面。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swagger serve ./swagger.json -F swagger</span><br><span class="line">2020/09/22 16:45:30 serving docs at http://localhost:33235/docs</span><br></pre></td></tr></table></figure>

<img data-src="/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/image-20200922164629425.png" class="" title="image-20200922164629425">



<h2 id="根据注解自动生成spec"><a href="#根据注解自动生成spec" class="headerlink" title="根据注解自动生成spec"></a>根据注解自动生成spec</h2><p>下面我们来看一下go-swagger注解指定的格式及转换规则。</p>
<h3 id="swagger-meta"><a href="#swagger-meta" class="headerlink" title="swagger:meta"></a>swagger:meta</h3><p>swagger:meta定义接口全局信息，主要有以下几个字段：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Terms Of Service</td>
<td>描述使用接口服务的一些协议，比如免责等</td>
</tr>
<tr>
<td>Consumes</td>
<td>描述接口默认请求的mime类型值，如果有多个，每个类型占据一行。支持的MIME类型有json，yaml，xml，txt，bin，urlform，multipartform</td>
</tr>
<tr>
<td>Produces</td>
<td>描述接口默认响应的mime类型值，如果有多个，每个类型占据一行</td>
</tr>
<tr>
<td>Schemes</td>
<td>描述接口默认支持的协议类型，可能的值有http，https，ws，wss</td>
</tr>
<tr>
<td>Version</td>
<td>当前接口的版本</td>
</tr>
<tr>
<td>Host</td>
<td>接口服务所在的域名</td>
</tr>
<tr>
<td>Base path</td>
<td>接口默认的根路径</td>
</tr>
<tr>
<td>Contact</td>
<td>通常来说是接口文档编写者的联系方式，格式：John <a href="mailto:&#68;&#97;&#x6e;&#x6a;&#111;&#x68;&#110;&#46;&#100;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#68;&#97;&#x6e;&#x6a;&#111;&#x68;&#110;&#46;&#100;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>License</td>
<td>接口文档遵循的许可证名称</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/docs.go</span></span><br><span class="line"><span class="comment">// Package classification echo-swagger-demo API.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the purpose of this application is to provide an application</span></span><br><span class="line"><span class="comment">// that is using plain go code to define an API</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This should demonstrate all the possible comment annotations</span></span><br><span class="line"><span class="comment">// that are available to turn go code into a fully compliant swagger 2.0 spec</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Terms Of Service:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// there are no TOS at this moment, use at your own risk we take no responsibility</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Schemes: http</span></span><br><span class="line"><span class="comment">//     Host: 10.7.11.134:1323</span></span><br><span class="line"><span class="comment">//     BasePath: /v2</span></span><br><span class="line"><span class="comment">//     Version: 0.0.1</span></span><br><span class="line"><span class="comment">//     License: MIT http://opensource.org/licenses/MIT</span></span><br><span class="line"><span class="comment">//     Contact: John Doe&lt;john.doe@example.com&gt; http://john.doe.com</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Consumes:</span></span><br><span class="line"><span class="comment">//     - application/json</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Produces:</span></span><br><span class="line"><span class="comment">//     - application/json</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Security:</span></span><br><span class="line"><span class="comment">//     - api_key:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     SecurityDefinitions:</span></span><br><span class="line"><span class="comment">//     api_key:</span></span><br><span class="line"><span class="comment">//          type: apiKey</span></span><br><span class="line"><span class="comment">//          name: KEY</span></span><br><span class="line"><span class="comment">//          in: header</span></span><br><span class="line"><span class="comment">//     oauth2:</span></span><br><span class="line"><span class="comment">//         type: oauth2</span></span><br><span class="line"><span class="comment">//         authorizationUrl: /oauth2/auth</span></span><br><span class="line"><span class="comment">//         tokenUrl: /oauth2/token</span></span><br><span class="line"><span class="comment">//         in: header</span></span><br><span class="line"><span class="comment">//         scopes:</span></span><br><span class="line"><span class="comment">//           bar: foo</span></span><br><span class="line"><span class="comment">//         flow: accessCode</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Extensions:</span></span><br><span class="line"><span class="comment">//     x-meta-value: value</span></span><br><span class="line"><span class="comment">//     x-meta-array:</span></span><br><span class="line"><span class="comment">//       - value1</span></span><br><span class="line"><span class="comment">//       - value2</span></span><br><span class="line"><span class="comment">//     x-meta-array-obj:</span></span><br><span class="line"><span class="comment">//       - name: obj</span></span><br><span class="line"><span class="comment">//         value: field</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// swagger:meta</span></span><br></pre></td></tr></table></figure>

<p>生成后的spec的渲染效果：</p>
<img data-src="/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/image-20200922165513541.png" class="" title="image-20200922165513541">

<h3 id="swagger-route"><a href="#swagger-route" class="headerlink" title="swagger:route"></a>swagger:route</h3><p>swagger:route 指定路由注解，格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">swagger:route [method] [path pattern] [?tag1 tag2 tag3] [operation id]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>method为HTTP请求方式</li>
<li>path pattern为请求url（去掉Base path前缀）</li>
<li>tag代表该接口归属的模块，一个路由指定多个tag，swagger UI 可以根据tag分组</li>
<li>operation id为该路由的唯一标识，供swagger:parameters使用</li>
</ul>
<p>swagger:route一行结束后一般会紧跟两行注释，表明该接口的用途，其中第一行为接口概要信息，以”.”结束；第二行为详细描述。最后Responses指定可能的响应头状态码及响应体名称，响应体名称与swagger:response对应。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/user.go</span></span><br><span class="line"><span class="comment">// swagger:route POST /login users login</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// check user&#x27;s password and login.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 用户登录接口blablabla</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Responses:</span></span><br><span class="line"><span class="comment">//       default: genericError</span></span><br><span class="line"><span class="comment">//       200: userLoginResponse</span></span><br><span class="line"><span class="comment">//       422: validationError</span></span><br></pre></td></tr></table></figure>



<h3 id="swagger-parameters"><a href="#swagger-parameters" class="headerlink" title="swagger:parameters"></a>swagger:parameters</h3><p>swagger:parameters指定请求参数的类型，格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">swagger:parameters [operationid1 operationid2]</span><br></pre></td></tr></table></figure>

<p>operationid用于指定该参数可用于哪些route，可指定多个。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/user.go</span></span><br><span class="line"><span class="comment">// swagger:parameters login</span></span><br><span class="line"><span class="keyword">type</span> UserLoginReqWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 用户登录认证需要用户名和密码</span></span><br><span class="line">   <span class="comment">// in: body</span></span><br><span class="line">   Body api.UserLoginReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////another file////////////</span></span><br><span class="line"><span class="comment">// api/user_parameters.go</span></span><br><span class="line"><span class="keyword">type</span> UserLoginReq <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name stand for username</span></span><br><span class="line">    <span class="comment">// Maximum length    : 3</span></span><br><span class="line">    <span class="comment">// example: lee</span></span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Password stand for user&#x27;s password</span></span><br><span class="line">    <span class="comment">// Maximum length    : 10</span></span><br><span class="line">    <span class="comment">// example: 123</span></span><br><span class="line">    Password <span class="keyword">string</span> <span class="string">`json:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>swagger:parameters可使用以下注解：</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Format</th>
</tr>
</thead>
<tbody><tr>
<td><strong>In</strong></td>
<td>参数位置：header、formData、path、query、body</td>
</tr>
<tr>
<td><strong>Collection Format</strong></td>
<td>when a slice the formatter for the collection when serialized on the request</td>
</tr>
<tr>
<td><strong>Maximum</strong></td>
<td>整数的最大值</td>
</tr>
<tr>
<td><strong>Minimum</strong></td>
<td>整数的最小值</td>
</tr>
<tr>
<td><strong>Multiple of</strong></td>
<td>倍数</td>
</tr>
<tr>
<td><strong>Minimum length</strong></td>
<td>字符串的最小长度</td>
</tr>
<tr>
<td><strong>Maximum length</strong></td>
<td>字符串的最大长度</td>
</tr>
<tr>
<td><strong>Pattern</strong></td>
<td>字符串正则模式</td>
</tr>
<tr>
<td><strong>Minimum items</strong></td>
<td>数组的最大长度</td>
</tr>
<tr>
<td><strong>Maximum items</strong></td>
<td>数组的最小长度</td>
</tr>
<tr>
<td><strong>Unique</strong></td>
<td>数组不允许有重复元素</td>
</tr>
<tr>
<td><strong>Required</strong></td>
<td>必填项目</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td>示例值</td>
</tr>
</tbody></table>
<p>指定数组内部元素的格式，数组下标n从0开始：</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Format</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Items.*n*.Maximum</strong></td>
<td>specifies the maximum a number or integer value can have at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Minimum</strong></td>
<td>specifies the minimum a number or integer value can have at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Multiple of</strong></td>
<td>specifies a value a number or integer value must be a multiple of</td>
</tr>
<tr>
<td><strong>Items.*n*.Minimum length</strong></td>
<td>the minimum length for a string value at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Maximum length</strong></td>
<td>the maximum length for a string value at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Pattern</strong></td>
<td>a regular expression a string value needs to match at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Minimum items</strong></td>
<td>the minimum number of items a slice needs to have at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Maximum items</strong></td>
<td>the maximum number of items a slice can have at the level <em>n</em></td>
</tr>
<tr>
<td><strong>Items.*n*.Unique</strong></td>
<td>when set to true the slice can only contain unique items at the level <em>n</em></td>
</tr>
</tbody></table>
<h3 id="swagger-response"><a href="#swagger-response" class="headerlink" title="swagger:response"></a>swagger:response</h3><p>swagger:response指定route所引用的响应体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">swagger:response [?response name]</span><br></pre></td></tr></table></figure>

<p>swagger:response可使用的注解与swagger:parameters相同。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/user.go</span></span><br><span class="line"><span class="comment">// A UserLoginRespWrapper is a response when user login with correct password.</span></span><br><span class="line"><span class="comment">// swagger:response userLoginResponse</span></span><br><span class="line"><span class="keyword">type</span> UserLoginRespWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// in: body</span></span><br><span class="line">    Body api.UserLoginResp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////another file////////////</span></span><br><span class="line"><span class="comment">// api/user_responses.go</span></span><br><span class="line"><span class="keyword">type</span> UserLoginResp <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Required: true</span></span><br><span class="line">    <span class="comment">// Example: Login success</span></span><br><span class="line">    Msg <span class="keyword">string</span> <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">    <span class="comment">// Required: true</span></span><br><span class="line">    <span class="comment">// Example: 200</span></span><br><span class="line">    Code <span class="keyword">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，为了清晰和职责分离，需要将文档和代码分离开，大部分的注解需要写到docs模块，在文档模块定义Wrapper包装代码模块定义的结构体，这样能有效减少注解比代码还长的场景OTZ。</p>
<p>定义好swagger:route、 swagger:parameters及swagger:response后的渲染结果：</p>
<img data-src="/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/image-20200922174004223.png" class="" title="image-20200922174004223">

<h3 id="swagger-strfmt"><a href="#swagger-strfmt" class="headerlink" title="swagger:strfmt"></a>swagger:strfmt</h3><p><strong>swagger:strfmt</strong>可以定义结构化的字符串，如UUID，Email等等，支持的格式如下：</p>
<ul>
<li>uuid, uuid3, uuid4, uuid5</li>
<li>email</li>
<li>uri (absolute)</li>
<li>hostname</li>
<li>ipv4</li>
<li>ipv6</li>
<li>credit card</li>
<li>isbn, isbn10, isbn13</li>
<li>social security number</li>
<li>hexcolor</li>
<li>rgbcolor</li>
<li>date</li>
<li>date-time</li>
<li>duration</li>
<li>password</li>
<li>custom string formats</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">swagger:strfmt [name]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// api/user_parameters.go</span></span><br><span class="line"><span class="keyword">type</span> RegisterReq <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name stand for username</span></span><br><span class="line">    <span class="comment">// Maximum length    : 6</span></span><br><span class="line">    <span class="comment">// Required: true</span></span><br><span class="line">    <span class="comment">// example: lee</span></span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; validate:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Password stand for user&#x27;s password</span></span><br><span class="line">    <span class="comment">// Maximum length    : 10</span></span><br><span class="line">    <span class="comment">// Required: true</span></span><br><span class="line">    <span class="comment">// example: 123456</span></span><br><span class="line">    Password <span class="keyword">string</span> <span class="string">`json:&quot;password&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Email stand for user&#x27;s email</span></span><br><span class="line">    <span class="comment">// Required: true</span></span><br><span class="line">    <span class="comment">// example: lee@uniontech.com</span></span><br><span class="line">    <span class="comment">// swagger:strfmt email</span></span><br><span class="line">    Email <span class="keyword">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Age stand for user&#x27;s password</span></span><br><span class="line">    <span class="comment">// example: 20</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="swagger-file"><a href="#swagger-file" class="headerlink" title="swagger:file"></a>swagger:file</h3><p>swagger:file注解用于指定某个参数为文件类型，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/user.go</span></span><br><span class="line"><span class="comment">// A UploadReqWrapper is the form for upload a file.</span></span><br><span class="line"><span class="comment">// swagger:parameters upload</span></span><br><span class="line"><span class="keyword">type</span> UploadReqWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Extra information describing the file</span></span><br><span class="line"><span class="comment">      In: formData</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Description *<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*The file to upload</span></span><br><span class="line"><span class="comment">      In: formData</span></span><br><span class="line"><span class="comment">      swagger:file</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    File os.File</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果：</p>
<img data-src="/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/image-20200922174503466.png" class="" title="image-20200922174503466">

<h3 id="swagger-enum"><a href="#swagger-enum" class="headerlink" title="swagger:enum"></a>swagger:enum</h3><p>swagger:enum用于限定某个参数的选取范围，swagger UI渲染为下拉菜单，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// docs/user.go</span></span><br><span class="line"><span class="comment">// A GetUsersReqWrapper is the query params for list users.</span></span><br><span class="line"><span class="comment">// swagger:parameters listUsers</span></span><br><span class="line"><span class="keyword">type</span> GetUsersReqWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">/*How many items want to fetch.</span></span><br><span class="line"><span class="comment">      In: query</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Limit *<span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*The last id that was seen.</span></span><br><span class="line"><span class="comment">      In: query</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Offset *<span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*the status to filter by</span></span><br><span class="line"><span class="comment">      Unique: true</span></span><br><span class="line"><span class="comment">      In: query</span></span><br><span class="line"><span class="comment">      Collection Format: pipes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Status []api.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////another file////////////</span></span><br><span class="line"><span class="comment">// api/user_parameters.go</span></span><br><span class="line"><span class="comment">// swagger:enum Status</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    STATUS_ACTIVE   Status = <span class="string">&quot;active&quot;</span></span><br><span class="line">    STATUS_DISABLED Status = <span class="string">&quot;disabled&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>渲染效果：</p>
<img data-src="/2020/09/22/go-swagger%E5%85%A5%E9%97%A8/image-20200922174835908.png" class="" title="image-20200922174835908">



<p>完整示例请查阅demo代码。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p><a href="https://goswagger.io/use/spec.html">https://goswagger.io/use/spec.html</a></p>
<p><a href="https://medium.com/@pedram.esmaeeli/generate-swagger-specification-from-go-source-code-648615f7b9d9">https://medium.com/@pedram.esmaeeli/generate-swagger-specification-from-go-source-code-648615f7b9d9</a></p>
<p><a href="https://juejin.im/post/6844903609390333965">https://juejin.im/post/6844903609390333965</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Dive into Casbin</title>
    <url>/2020/09/17/Dive-into-Casbin/</url>
    <content><![CDATA[<p>本文详细介绍Casbin的PERM模型，常用的访问控制模型及casbin（golang）的使用。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近年来，越来越多的企业向云平台迁移，云计算已经成为企业减少开销、按需分配计算资源的重要手段；但是当前各大云厂商存在多种不同的访问控制机制、策略语言，使得用户在做迁移时不得不投入大量人力。</p>
<p>Casbin是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。旨在提供<strong>策略语言无关性</strong>、<strong>访问控制模型无关性</strong>和<strong>程序设计语言无关性</strong>的权限管理框架。通过抽象出PERM模型，在业务需要更换访问控制模型时，只需重新配置PERM模型，并不需要对业务代码进行大幅改动。</p>
<h2 id="PML语言"><a href="#PML语言" class="headerlink" title="PML语言"></a>PML语言</h2><p>什么是PML及PERM？</p>
<p>PERM建模语言(PERM modeling language， 简称PML)来表达访问控制模型及其策略规则，PML语言是一个元模型语言， 其基于PERM(policy-effect-request-matcher)元模型。PERM元模型如下图所示， 包含4个基本原语：Request、Policy、Effect、Matcher， 1个可选原语：Role以及若干特性， 如域、属性、桩函数等。</p>


<h3 id="Request原语"><a href="#Request原语" class="headerlink" title="Request原语"></a>Request原语</h3><p>Request原语是对访问请求的抽象，其定义了访问请求的语义。一个访问请求通常由经典的三元组构成：进行访问的主体(subject)、被访问的客体(object)、访问动作(action)。PML中描述上述三元组的Request原语可表示为：</p>
<p><strong><em>r = sub, obj, act</em></strong></p>
<p>PML提供了自定制Request原语的能力，例如如果不需要控制到具体的资源，可以采用sub， act两元组的格式。如果主体需要采用所属域等额外信息来标识的话，可以采用domain， sub， obj， act四元组作为Request原语声明。如果使用ABAC则可以自行扩展请求格式（见代码demo）。</p>
<h3 id="Policy原语"><a href="#Policy原语" class="headerlink" title="Policy原语"></a>Policy原语</h3><p>Policy原语定义了策略规则的语义。该字段制定了PML策略的解释器应如何解释策略规则。为简单起见，本文采用逗号分隔值(comma-separated values， CSV)来作为策略规则的语法。与Request原语类似，经典的Policy原语也由主体、客体、动作三元组构成：</p>
<p><strong><em>p = sub, obj, act</em></strong></p>
<p>与其相应的策略规则可以为：</p>
<p><strong><em>p, alice, data1, read</em></strong></p>
<p>策略中的每一行都是一条策略规则。策略规则的第一个元素是策略类型，该字段与Policy原语相对应，通过指定不同的策略类型可以支持多个Policy原语，如p， p2等。通常情况下，不需要指定多个策略类型。上面的策略规则与之前的经典Policy原语的绑定关系为：</p>
<p><strong><em>(alice, data1, read) → (p.sub, p.obj, p.act)</em></strong></p>
<p>上述绑定类似于变量赋值，可以在Matcher原语中使用。</p>
<h3 id="Matcher原语"><a href="#Matcher原语" class="headerlink" title="Matcher原语"></a>Matcher原语</h3><p>Matcher原语定义了策略规则如何与访问请求进行匹配的匹配器，其本质上是布尔表达式。可以理解为Request、Policy等原语定义了关于策略和请求的变量，然后将这些变量代入Matcher原语中求值，从而进行策略决策。Matcher原语支持+， -， *， /等算数运算符、==， !=， &gt;， &lt;等关系运算符以及&amp;&amp; (与)， || (或)， ! (非)等逻辑运算符。Matcher原语最终的运算结果应为布尔值0或1，1表示策略规则满足该匹配器，0则表示不满足。与上节中列举的经典Policy原语相对应的Matcher原语为：</p>
<p><strong><em>m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</em></strong></p>
<p>该Matcher原语表示，访问请求中的主体、客体、动作三元组应与策略规则中的主体、客体、动作三元组分别对应相同。</p>
<h3 id="Effect原语"><a href="#Effect原语" class="headerlink" title="Effect原语"></a>Effect原语</h3><p>Effect原语定义了当多个策略规则同时匹配访问请求时，该如何对多个决策结果进行集成以实现统一决策，决策结果包括allow和deny两种。Effect原语支持some， any等量词以及条件关键字where、&amp;&amp; (与)， || (或)， ! (非)等逻辑运算符。some量词判断是否存在一条策略规则满足匹配器，any量词则判断是否所有的策略规则都满足匹配器。Where关键字表示后面跟策略规则的筛选条件。Effect原语可以表达<strong>允许优先</strong>(allow-override)、<strong>拒绝优先</strong>(deny-override)等多种决策集成方法。允许优先可以表达为：</p>
<p><strong><em>e = some(where (p.eft == allow))</em></strong></p>
<p>该Effect原语表示如果存在任意一个决策结果为allow的匹配规则，则最终决策结果为allow，即allow-override。其中p.eft表示策略规则的决策结果，可以为allow或者deny。当不指定规则的决策结果时，取默认值allow。利用Effect原语还可以表达拒绝优先：</p>
<p><strong><em>e = !some(where (p.eft == deny))</em></strong></p>
<p>该Effect原语表示不存在任何决策结果为deny的匹配规则，则最终决策结果为allow，否则为deny。Effect原语还可以利用逻辑运算符进行连接：</p>
<p><strong><em>e = some(where (p.eft == allow)) &amp;&amp; !some(where (p.eft == deny))</em></strong></p>
<p>该Effect原语表示当至少存在一个决策结果为allow的匹配规则，且不存在决策结果为deny的匹配规则时，则最终决策结果为allow。这时正向授权和负向授权同时存在，并且拒绝优先。</p>
<h3 id="Role原语"><a href="#Role原语" class="headerlink" title="Role原语"></a>Role原语</h3><p>Role原语定义了RBAC中的角色继承关系。该原语的特点是支持多重RBAC体系的表达。如当主体和客体同时具有角色(或组)的概念时，主体角色和客体角色两套RBAC体系可以互不干扰。同时支持主体角色和客体角色的Role原语可以定义如下：</p>
<p><strong><em>g = _, _</em></strong></p>
<p><strong><em>g2 = _, _</em></strong></p>
<p>上述Role原语表示g是一个RBAC体系，g2是另一个RBAC体系。_， _表示角色继承关系的前项和后项，即前项继承后项角色的权限。PML把角色继承关系也表达为策略规则，如：</p>
<p><strong><em>g, alice, data2_admin</em></strong></p>
<p>上述策略规则表示alice具有角色data2_admin。这里的alice可以为具体的某个主体或者另一个角色。g则表示策略类型，与Role原语相对应。在Matcher原语中，请求主体与策略规则主体之间的是否具有角色继承关系可以用布尔函数g(r.sub, p.sub)来表达，值为1表示两者具有角色继承关系，0则表示不具备该关系。角色继承关系支持间接继承。可以看出，<strong>Matcher原语中的一个布尔函数g，与Role原语中的g和策略规则中相应的策略类型g互相对应，共同完成RBAC角色的指派。</strong>其他RBAC体系，如g2用法类似，这里不再赘述。下面例子给出完整的Matcher原语：</p>
<p><strong><em>m = g(r.sub， p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</em></strong></p>
<p>该Matcher原语表达了经典的RBAC场景：策略规则定义哪些角色可以具备哪些权限(即采用哪种动作访问哪个资源)，只有当请求主体继承策略规则中指定的角色，并且请求与策略规则中的资源和动作对应相同时，Matcher原语才会成功匹配该请求与该策略规则。</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>云平台中通常存在租户的概念。为了实现灵活的授权管理，PML通过域内Role原语来支持租户内的授权。<strong>一个域代表一个租户，域内角色只在本域内生效，也只能分配本域内的资源的权限。</strong>域内角色机制实现了云平台租户间的安全隔离。域内Role原语可以定义为：</p>
<p><strong><em>g = _, _, _</em></strong></p>
<p>原语中第三个_表示域的概念。相对应的策略规则的实例如下：</p>
<p><strong><em>p, admin, tenant1, data1, read</em></strong></p>
<p><strong><em>p, admin, tenant2, data2, read</em></strong></p>
<p><strong><em>g, alice, admin, tenant1</em></strong></p>
<p><strong><em>g, alice, user, tenant2</em></strong></p>
<p>相对应的Matcher原语可以为：</p>
<p><strong><em>m = g(r.sub, p.sub, r.dom) &amp;&amp; r.dom == p.dom &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</em></strong></p>
<p>该实例表示tenant1的域内角色admin可以读取data1，tenant2的域内角色admin可以读取data2。Alice是在tenant1域中是admin角色，但在tenant2域中是user角色，因此根据策略规则，alice只能读取data1而不能读取data2。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>为了支持ABAC的属性概念，PML采用.(点)语法来表达元素属性(元素即主体、客体、动作等)。属性本身也是元素，因此可以继续获取属性的属性。例如，r.sub.domain表示访问请求的主体所在的域，而r.sub.domain.owner则表示该域的所有者。</p>
<p><strong><em>m = r.sub.domain == r.obj.domain</em></strong></p>
<p>上述Matcher原语表示只有当请求的主体所在的域与请求的客体所在的域相同时，才允许该请求。PML本身也依赖与属性类似的语法。如r.sub可理解为请求r这个元素的sub属性。通过提供一致的语法，有助于降低策略编写者学习语言的成本。</p>
<h3 id="桩函数"><a href="#桩函数" class="headerlink" title="桩函数"></a>桩函数</h3><p>虽然PML的Matcher原语通过各种运算符提供了强大的表达能力，仍然有一些复杂的处理逻辑无法用PML表达，如查询外部数据库、进行复杂数学运算等。PML中提供了桩函数机制以满足自定义处理逻辑的需求。策略编写者可以在PML以外以其他程序设计语言自定义若干桩函数(stub function)，然后将这些函数注册到PML中，从而被PML的Matcher原语所识别和调用。桩函数与普通函数类似，可以带有多个参数，并具有返回值。下面给出桩函数my_func的例子。my_func判断请求客体与策略规则客体之间是否匹配，并返回布尔值。首先需要将该函数进行注册：</p>
<p><strong><em>register_function(“my_func”,  my_func)</em></strong></p>
<p>my_func的实现可以如下：</p>
<p><strong><em>boolean my_func(r.obj, p.obj) {</em></strong></p>
<p><strong><em>return r.obj == p.obj</em></strong></p>
<p><strong><em>}</em></strong></p>
<p>这样就可以在Matcher原语中指定该函数，参与到匹配中：</p>
<p><strong><em>m = r.sub == p.sub &amp;&amp; my_func(r.obj, p.obj) &amp;&amp; r.act == p.act</em></strong></p>
<p>PML提供内置的桩函数，以满足常用Matcher匹配需求。如keyMatch(r.obj， p.obj)函数支持匹配RESTful路径，当请求中的RESTful路径匹配策略规则时返回布尔值1，并允许以“*”作为通配符。regexMatch(r.obj, p.obj)函数则提供了更强大的正则表达式匹配的功能，当请求中的客体匹配策略规则中指定的正则表达式时返回布尔值。</p>
<h2 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h2><p>ACL、RBAC、ABAC</p>
<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p><code>ACL</code>是<code>Access Control List</code>的缩写，称为访问控制列表. 定义了谁可以对某个数据进行何种操作。</p>
<p>ACL规则十分简单, 但当用户数或资源的数量较大时, 维护成本较高。</p>
<p><strong>典型应用</strong></p>
<ul>
<li>文件系统</li>
</ul>
<p>文件系统的文件或文件夹定义某个账号(user)或某个群组(group)对文件(夹)的读(read)/写(write)/执行(execute)权限.</p>
<ul>
<li>网络访问</li>
</ul>
<p>服务器限制不允许指定机器访问其指定端口, 或允许特定指定服务器访问其指定几个端口。</p>
<p>示例：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># acl_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p><strong>model.conf文件解析</strong>：</p>
<ul>
<li>request_definition块对应Request原语</li>
<li>policy_definition块对应Policy原语</li>
<li>matchers块对应Matcher原语</li>
<li>policy_effect块对应Effect原语</li>
</ul>
<p>Policy文件内容承载了具体的权限规则数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># acl_policy.csv</span></span><br><span class="line">p, alice, data1, read</span><br><span class="line">p, bob, data2, write</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnforce</span><span class="params">(e *casbin.Enforcer, sub <span class="keyword">interface</span>&#123;&#125;, obj <span class="keyword">interface</span>&#123;&#125;, act <span class="keyword">string</span>, res <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若与预期不符，打印错误信息</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(sub, obj, act); ok != res &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s, %v, %s: %t, supposed to be %t\n&quot;</span>, sub, obj, act, !res, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestACL</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;acl_model.conf&quot;</span>, <span class="string">&quot;acl_policy.csv&quot;</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 只对data1有读权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// bob 只对data2有写权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p><code>RBAC</code>是<code>Role-based access control</code>的缩写，称为 基于角色的访问控制。核心数据模型有：用户、 角色、 权限。用户具有角色， 而角色具有权限,，从而表达用户具有权限。由于有角色作为中间纽带, 当新增用户时, 只需要为用户赋予角色，用户即获得角色所包含的所有权限。RBAC解决了ACL在用户或资源数量庞大时维护困难的问题。</p>
<h4 id="普通RBAC"><a href="#普通RBAC" class="headerlink" title="普通RBAC"></a>普通RBAC</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[role_definition]</span></span><br><span class="line"><span class="attr">g</span> = _, _</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p>role_definition块为RBAC模型独有的配置区，<code>g = _,_</code>定义了用户——角色或者角色——角色的映射关系，前者是后者的成员，拥有后者的权限。匹配器中的<code>g(r.sub, p.sub)</code>用于判段<code>r.sub</code>是否属于<code>p.sub</code>这个角色。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_policy.csv</span></span><br><span class="line">p, alice, data1, read</span><br><span class="line">p, bob, data2, write</span><br><span class="line"><span class="comment"># ata2_admin对data2有读写权限</span></span><br><span class="line">p, data2_admin, data2, read  </span><br><span class="line">p, data2_admin, data2, write</span><br><span class="line"></span><br><span class="line"><span class="comment"># alice 在data2_admin组</span></span><br><span class="line">g, alice, data2_admin </span><br></pre></td></tr></table></figure>



<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRBAC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;rbac_model.conf&quot;</span>, <span class="string">&quot;rbac_policy.csv&quot;</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 只对data1有读权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 在data2_admin组，data2_admin对data2有读写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 在data2_admin组，data2_admin对data2有读写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// bob 只对data2有写权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多级RBAC"><a href="#多级RBAC" class="headerlink" title="多级RBAC"></a>多级RBAC</h4><p><code>casbin</code>还能为角色定义所属角色，从而实现多级角色关系，这种权限关系是可以传递的。</p>
<p>继续使用上一部的权限模型rbac_model.conf，新建policy文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rbac_with_hierarchy_policy.csv</span><br><span class="line">p, alice, data1, read</span><br><span class="line">p, bob, data2, write</span><br><span class="line">p, data1_admin, data1, read</span><br><span class="line">p, data1_admin, data1, write</span><br><span class="line">p, data2_admin, data2, read</span><br><span class="line">p, data2_admin, data2, write</span><br><span class="line"></span><br><span class="line">g, alice, admin</span><br><span class="line">g, admin, data1_admin</span><br><span class="line">g, admin, data2_admin</span><br></pre></td></tr></table></figure>

<p>alice 通过admin，继承了data1_admin和data2_admin的权限。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRBACWithHierarchy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;rbac_model.conf&quot;</span>, <span class="string">&quot;rbac_with_hierarchy_policy.csv&quot;</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 对data1有读权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 对data1有写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 在admin组，admin在data2_admin组，data2_admin对data2有读写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 在admin组，admin在data2_admin组，data2_admin对data2有读写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// bob 只对data2有写权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多种RBAC"><a href="#多种RBAC" class="headerlink" title="多种RBAC"></a>多种RBAC</h4><p><code>casbin</code>支持同时存在多个<code>RBAC</code>系统，即用户和资源都有角色：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_with_resource_roles_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[role_definition]</span></span><br><span class="line"><span class="attr">g</span> = _, _</span><br><span class="line"><span class="attr">g2</span> = _, _</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = g(r.sub, p.sub) &amp;&amp; g2(r.obj, p.obj) &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p>上面的模型文件定义了两个<code>RBAC</code>系统<code>g</code>和<code>g2</code>，我们在匹配器中使用<code>g(r.sub, p.sub)</code>判断请求主体属于特定组，<code>g2(r.obj, p.obj)</code>判断请求资源属于特定组，且操作一致即可放行。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_with_resource_roles_policy.csv</span></span><br><span class="line">p, alice, data1, read</span><br><span class="line">p, bob, data2, write</span><br><span class="line">p, data_group_admin, data_group, write</span><br><span class="line"></span><br><span class="line">g, alice, data_group_admin</span><br><span class="line">g2, data1, data_group</span><br><span class="line">g2, data2, data_group</span><br></pre></td></tr></table></figure>

<p>上面的策略文件表示，alice属于data_group_admin，资源data1和资源data2都属于data_group，且data_group_admin对data_group中的资源有写权限，所以alice对data1和data2都有了写权限。</p>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRBACWithResourceRoles</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;rbac_with_resource_roles_model.conf&quot;</span>, <span class="string">&quot;rbac_with_resource_roles_policy.csv&quot;</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 对data1有读权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 对data1有写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice从data_group_admin继承对data2的写权限</span></span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// bob 只对data2有写权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RBAC-with-Domain"><a href="#RBAC-with-Domain" class="headerlink" title="RBAC with Domain"></a>RBAC with Domain</h4><p>在<code>casbin</code>中，角色可以是全局的，也可以是特定<code>domain</code>（领域）或<code>tenant</code>（租户），可以简单理解为<strong>域</strong>。例如alice在域<code>tenant1</code>中是管理员，拥有比较高的权限，在<code>tenant2</code>可能只是个弟弟。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_with_domains_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, dom, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub, dom, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[role_definition]</span></span><br><span class="line"><span class="attr">g</span> = _, _, _</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = g(r.sub, p.sub, r.dom) &amp;&amp; r.dom == p.dom &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p><code>g=_,_,_</code>表示前者在后者中拥有中间定义的角色，在匹配器中使用<code>g</code>要带上<code>domain</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rbac_with_domains_policy.csv</span></span><br><span class="line">p, admin, domain1, data1, read</span><br><span class="line">p, admin, domain1, data1, write</span><br><span class="line">p, admin, domain2, data2, read</span><br><span class="line">p, admin, domain2, data2, write</span><br><span class="line">g, alice, admin, domain1</span><br><span class="line">g, bob, admin, domain2</span><br></pre></td></tr></table></figure>

<p>policy策略表明alice在domain1为admin角色，bob在domain2为admin角色。</p>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRBACWithDomain</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;rbac_with_domains_model.conf&quot;</span>, <span class="string">&quot;rbac_with_domains_policy.csv&quot;</span>)</span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;domain1&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)  <span class="comment">// alice 对data1有读权限</span></span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;domain1&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// alice 对data1有写权限</span></span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;domain2&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;domain2&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;domain2&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    testEnforceWithDomain(e, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;domain2&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>) <span class="comment">// bob 只对data2有写权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p><code>ABAC</code>是<code>Attribute-based access control</code>的缩写，称为基于属性的访问控制。ABAC适用于特殊的、动态的权限控制需求。</p>
<p><strong>典型应用：</strong></p>
<ul>
<li>特定时间段不同的策略;</li>
<li>年龄分级准入控制</li>
<li>发帖者可以编辑/删除评论(如果是RBAC, 会为发帖者定义一个角色, 但是每个帖子都要新增一条用户/发帖角色的记录);</li>
<li>微信聊天消息超过2分钟则不再允许撤回;</li>
<li>12306 只有实名认证后的账号才能购票;</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abac_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, obj, act, env</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub, obj,act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = r.sub.Role==<span class="string">&#x27;Teacher&#x27;</span> &amp;&amp; r.obj.Name==<span class="string">&#x27;School Gate&#x27;</span> &amp;&amp; r.act in(<span class="string">&#x27;In&#x27;</span>,<span class="string">&#x27;Out&#x27;</span>) &amp;&amp; r.env.Time.Hour &gt;=<span class="number">8</span> &amp;&amp; r.env.Time.Hour &lt;= <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>request_definition中定义了传给Enforce()方法的参数个数，分别是sub, obj, act, env。单纯的ABAC模式可以不指定任何policy，Enforce()方法根据传入的参数代入matchers进行动态判断（归功于<a href="https://github.com/Knetic/govaluate">govaluate库</a>），结合policy_effect计算出最终结果。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestABAC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">        Role <span class="keyword">string</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> Env <span class="keyword">struct</span> &#123;</span><br><span class="line">        Time time.Time</span><br><span class="line">    &#125;</span><br><span class="line">    initEnv := <span class="function"><span class="keyword">func</span><span class="params">(hour <span class="keyword">int</span>)</span> *<span class="title">Env</span></span> &#123;</span><br><span class="line">        env := &amp;Env&#123;&#125;</span><br><span class="line">        env.Time = time.Date(<span class="number">2020</span>, <span class="number">9</span>, <span class="number">17</span>, hour, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">        <span class="keyword">return</span> env</span><br><span class="line">    &#125;</span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;abac_model.conf&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    lee, schoolGate, act, env := User&#123;Name: <span class="string">&quot;lee&quot;</span>, Role: <span class="string">&quot;Teacher&quot;</span>&#125;, Subject&#123;Name: <span class="string">&quot;School Gate&quot;</span>&#125;, <span class="string">&quot;In&quot;</span>, initEnv(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(lee, schoolGate, act, env); ok != <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;不符合预期！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lee, schoolGate, act, env = User&#123;Name: <span class="string">&quot;lee&quot;</span>, Role: <span class="string">&quot;Teacher&quot;</span>&#125;, Subject&#123;Name: <span class="string">&quot;School Gate&quot;</span>&#125;, <span class="string">&quot;Out&quot;</span>, initEnv(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(lee, schoolGate, act, env); ok != <span class="literal">false</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;不符合预期！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wang, schoolGate, act, env := User&#123;Name: <span class="string">&quot;wang&quot;</span>, Role: <span class="string">&quot;Student&quot;</span>&#125;, Subject&#123;Name: <span class="string">&quot;School Gate&quot;</span>&#125;, <span class="string">&quot;Out&quot;</span>, initEnv(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(wang, schoolGate, act, env); ok != <span class="literal">false</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;不符合预期！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>适配复杂且大量的ABAC规则</strong></p>
<p>上面一个例子的问题在于，一旦管理的对象变更，需要修改model.conf，而权限模型文件一般是不允许变更的。Casbin 提供了eval()函数，可以把规则写入policy文件，这样也有了RBAC和ABAC搭配使用的能力。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abac_with_policy_model.conf</span></span><br><span class="line"><span class="section">[request_definition]</span></span><br><span class="line"><span class="attr">r</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_definition]</span></span><br><span class="line"><span class="attr">p</span> = sub_rule, obj, act</span><br><span class="line"></span><br><span class="line"><span class="section">[policy_effect]</span></span><br><span class="line"><span class="attr">e</span> = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line"><span class="section">[matchers]</span></span><br><span class="line"><span class="attr">m</span> = eval(p.sub_rule) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p><code>eval()</code>函数去匹配policy文件中的策略：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abac_with_policy_policy.csv</span></span><br><span class="line">p, r.sub.Age &gt; 18, /data1, read</span><br><span class="line">p, r.sub.Age &lt; 60, /data2, write</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestABACWithPolicy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age  <span class="keyword">int</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e, _ := newEnforcer(<span class="string">&quot;abac_with_policy_model.conf&quot;</span>, <span class="string">&quot;abac_with_policy_policy.csv&quot;</span>)</span><br><span class="line">    zhao, qian := User&#123;Age: <span class="number">20</span>, Name: <span class="string">&quot;zhao&quot;</span>&#125;, User&#123;Age: <span class="number">16</span>, Name: <span class="string">&quot;qian&quot;</span>&#125;</span><br><span class="line">    testEnforce(e, zhao, <span class="string">&quot;/data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    testEnforce(e, zhao, <span class="string">&quot;/data1&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, zhao, <span class="string">&quot;/data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    testEnforce(e, zhao, <span class="string">&quot;/data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, qian, <span class="string">&quot;/data1&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, qian, <span class="string">&quot;/data1&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">    testEnforce(e, qian, <span class="string">&quot;/data2&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    testEnforce(e, qian, <span class="string">&quot;/data2&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="模型存储"><a href="#模型存储" class="headerlink" title="模型存储"></a>模型存储</h3><h4 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := casbin.NewEnforcer(<span class="string">&quot;examples/rbac_model.conf&quot;</span>, <span class="string">&quot;examples/rbac_policy.csv&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从代码加载"><a href="#从代码加载" class="headerlink" title="从代码加载"></a>从代码加载</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the model from Go code.</span></span><br><span class="line">m := model.NewModel()</span><br><span class="line">m.AddDef(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;sub, obj, act&quot;</span>)</span><br><span class="line">m.AddDef(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;sub, obj, act&quot;</span>)</span><br><span class="line">m.AddDef(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;_, _&quot;</span>)</span><br><span class="line">m.AddDef(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;some(where (p.eft == allow))&quot;</span>)</span><br><span class="line">m.AddDef(<span class="string">&quot;m&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the policy rules from the .CSV file adapter.</span></span><br><span class="line"><span class="comment">// 使用自己的 adapter 替换。</span></span><br><span class="line">a := persist.NewFileAdapter(<span class="string">&quot;examples/rbac_policy.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 enforcer。</span></span><br><span class="line">e := casbin.NewEnforcer(m, a)</span><br></pre></td></tr></table></figure>

<h4 id="从字符串加载"><a href="#从字符串加载" class="headerlink" title="从字符串加载"></a>从字符串加载</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the model from a string.</span></span><br><span class="line">text :=</span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">[request_definition]</span></span><br><span class="line"><span class="string">r = sub, obj, act</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[policy_definition]</span></span><br><span class="line"><span class="string">p = sub, obj, act</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[role_definition]</span></span><br><span class="line"><span class="string">g = _, _</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[policy_effect]</span></span><br><span class="line"><span class="string">e = some(where (p.eft == allow))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[matchers]</span></span><br><span class="line"><span class="string">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">m := NewModel(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the policy rules from the .CSV file adapter.</span></span><br><span class="line"><span class="comment">// Replace it with your adapter to avoid files.</span></span><br><span class="line">a := persist.NewFileAdapter(<span class="string">&quot;examples/rbac_policy.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the enforcer.</span></span><br><span class="line">e := casbin.NewEnforcer(m, a)</span><br></pre></td></tr></table></figure>



<h3 id="策略存储"><a href="#策略存储" class="headerlink" title="策略存储"></a>策略存储</h3><p>在Casbin中，策略存储作为adapter实现，Casbin只内置了简单的csv文件存储实现，如果需要存至database或其他位置，需要实现Adapter接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adapter is the interface for Casbin adapters.</span></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// LoadPolicy loads all policy rules from the storage.</span></span><br><span class="line">    LoadPolicy(model model.Model) error</span><br><span class="line">    <span class="comment">// SavePolicy saves all policy rules to the storage.</span></span><br><span class="line">    SavePolicy(model model.Model) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddPolicy adds a policy rule to the storage.</span></span><br><span class="line">    <span class="comment">// This is part of the Auto-Save feature.</span></span><br><span class="line">    AddPolicy(sec <span class="keyword">string</span>, ptype <span class="keyword">string</span>, rule []<span class="keyword">string</span>) error</span><br><span class="line">    <span class="comment">// RemovePolicy removes a policy rule from the storage.</span></span><br><span class="line">    <span class="comment">// This is part of the Auto-Save feature.</span></span><br><span class="line">    RemovePolicy(sec <span class="keyword">string</span>, ptype <span class="keyword">string</span>, rule []<span class="keyword">string</span>) error</span><br><span class="line">    <span class="comment">// RemoveFilteredPolicy removes policy rules that match the filter from the storage.</span></span><br><span class="line">    <span class="comment">// This is part of the Auto-Save feature.</span></span><br><span class="line">    RemoveFilteredPolicy(sec <span class="keyword">string</span>, ptype <span class="keyword">string</span>, fieldIndex <span class="keyword">int</span>, fieldValues ...<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>LoadPolicy</code>和<code>SavePolicy</code>为必须实现的方法，其余方法是可选的（提供一个空实现即可），实现这些可选方法即可开启策略修改自动保存的特性，否则修改策略后，需要手动调用SavePolicy方法以持久化本次修改。SavePolicy方法将删除存储中的所有策略规则，并将所有策略规则从Casbin enforcer保存到存储中，当策略规则的数量较多时，使用<code>SavePolicy()</code>可能会出现性能问题。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadPolicy()</td>
<td>强制的</td>
<td>从存储中加载所有策略规则</td>
</tr>
<tr>
<td>SavePolicy()</td>
<td>强制的</td>
<td>将所有策略规则保存到存储中</td>
</tr>
<tr>
<td>AddPolicy()</td>
<td>可选择的</td>
<td>向存储中添加策略规则</td>
</tr>
<tr>
<td>RemovePolicy()</td>
<td>可选择的</td>
<td>从存储中删除策略规则</td>
</tr>
<tr>
<td>RemoveFilteredPolicy()</td>
<td>可选择的</td>
<td>从存储中删除匹配筛选器的策略规则</td>
</tr>
</tbody></table>
<h2 id="权限管理API"><a href="#权限管理API" class="headerlink" title="权限管理API"></a>权限管理API</h2><p>https：//casbin.org/docs/zh-CN/management-api</p>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><h3 id="Dispatchers"><a href="#Dispatchers" class="headerlink" title="Dispatchers"></a>Dispatchers</h3><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.jos.org.cn/html/2020/2/5624.htm#outline_anchor_6">http://www.jos.org.cn/html/2020/2/5624.htm#outline_anchor_6</a></p>
<p><a href="https://juejin.im/post/6844904191257739277#heading-3">https://juejin.im/post/6844904191257739277#heading-3</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1534674">https://cloud.tencent.com/developer/article/1534674</a></p>
<p><a href="https://casbin.org/docs/zh-CN/overview">https://casbin.org/docs/zh-CN/overview</a></p>
<p><a href="https://casbin.org/en/editor/">https://casbin.org/en/editor/</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
